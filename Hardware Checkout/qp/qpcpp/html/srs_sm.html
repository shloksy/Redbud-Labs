<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: State Machines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C++
    &nbsp;<span id="projectnumber">7.2.1</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('srs_sm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">State Machines </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="srs_evt.html">Events</a></span><span class="next_button"><a class="el" href="srs_ao.html">Active Objects</a></span> </p>
<p>The behavior of event-driven components (Active Objects, as well as passive event-driven objects) is specified in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Applications through <a href="https://www.state-machine.com/fsm#HSM" class="extern" target="_blank">Hierarchical State Machines</a> (a.k.a. UML statecharts). The main effort of <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Application developers typically goes into elaborating the internal state machines of the various objects in the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Application. Therefore the description of state machine features and associated requirements is provided early in this SRS document.</p>
<h1><a class="anchor" id="srs_sm_impl"></a>
State Machine Implementation Strategies</h1>
<p>State Machines, and Hierarchical State Machines, in particular, can be implemented in many different ways. A specific way of implementing a state machine will be called here a <b>State Machine Implementation Strategy</b>, and it can be characterized by the following properties:</p>
<ul>
<li>efficiency in time (CPU cycles)</li>
<li>efficiency in data space (RAM footprint)</li>
<li>efficiency in code space (ROM footprint)</li>
<li>monolithic vs. partitioned with various levels of granularity</li>
<li>maintainability (with manual coding)</li>
<li>maintainability (via automatic code generation)</li>
<li><em>traceability</em> from design (e.g., state diagram) to code</li>
<li><em>traceability</em> from code back to design</li>
<li>other, quality attributes (non-functional requirements)</li>
</ul>
<p>No single State Machine Implementation Strategy can be optimal for all circumstances, and therefore <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support multiple and interchangeable strategies (see <a class="el" href="srs_sm.html#RQP102">RQP102</a>).</p>
<h1><a class="anchor" id="src_sm_proc"></a>
Dispatching Events to a State Machine in QP Framework</h1>
<p>The event processing inside a state machine is called <b>dispatching</b> an event to the state machine, and it requires interaction between the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework and the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Application:</p>
<div class="image">
<img src="sm_proc.png" alt=""/>
</div>
  <div class="caption"><center><b>Event Dispatching to a State Machine in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework</b></center></div><h2><a class="anchor" id="srs_sm_spec"></a>
State Machine Specification</h2>
<p>The "State Machine Specification" is provided inside the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Application and is prepared according to the rules defined by the chosen State Machine Implementation Strategy in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework. Typically an implementation strategy represents a state machine as several elements, such as states, transitions, etc.</p>
<p>The "State Machine Specification" can mean state machine code (when the state machine is coded manually) or a state machine model (when the state machine is specified in a modeling tool, like <a href="https://www.state-machine.com//products/qm" class="extern" target="_blank">"QM"</a>). Either way, it is highly recommended to <em>think</em> of the state machine implementation as the <b>specification</b> of state machine elements, not merely code. This notion of "specifying" a state machine rather than coding it can be reinforced by selecting an expressive and fully <em>traceable</em> state machine implementation strategy, see <a class="el" href="srs_sm.html#RQP103">RQP103</a>. The advantage of a traceable implementation is that each artifact at all levels of abstraction (design to code) unambiguously represents an element of a state machine.</p>
<h2><a class="anchor" id="srs_sm_proc"></a>
State Machine Processor</h2>
<p>A state machine is executed in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework by the "State Machine Processor" that decides which elements of the "State Machine Specification" to call (see also srs_intro_inv). Once called, the chosen part of the "State Machine Specification" executes some actions and <em>returns</em> back to the "State Machine Processor" (<a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework) with the status information as to what has happened. For example, the returned status might inform the "State Machine Processor" that a state transition needs to be taken, or that the event needs to be propagated to the superstate in the hierarchical state machine.</p>
<h2><a class="anchor" id="srs_sm_rtc"></a>
Run To Completion (RTC) Processing</h2>
<p>The "State Machine Processor" is a <em>passive</em> software component that needs to be explicitly called from some control thread to dispatch each event to the given state machine object. The most important restriction is that the dispatch operation must necessarily run to completion (<b>Run-to-Completion</b> processing) before another event can be dispatched to the same state machine object.</p>
<dl class="section note"><dt>Note</dt><dd>RTC event processing does <b>NOT</b> mean that a state machine has to monopolize the CPU until the RTC step is complete. In a multithreading environment, other threads or interrupts (not related to the thread context of the busy state machine) <em>can</em> be running, possibly preempting the currently executing state machine. But after every preemption, the preempted state machine picks up where it left off and continues processing the current event, eventually completing its RTC step.<br  />
 <br  />
 RTC event processing also means that a state machine should <b>NOT</b> make blocking calls (e.g., a time-delay or semaphore-wait), because every blocking call represents waiting for an <em>event</em>, which will be delivered after the call unblocks. The problem is that such a "backdoor" event is delivered before the original RTC step completes, thus violating the RTC semantics. Blocking inside a state machine also extends the RTC processing and makes the state machine unresponsive to new events.</dd></dl>
<h1><a class="anchor" id="src_sm_req"></a>
Requirements</h1>
<p><a id="a9_RQP101" name="a9_RQP101"></a> </p><hr  />
<h2><a class="anchor" id="RQP101"></a>
RQP101</h2>
<p><a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall provide support for hierarchical state machines both for Active Objects and for passive event-driven objects in the Application</p>
<dl class="section user"><dt>Amplification</dt><dd>Support for hierarchical state machines (HSMs) means that <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework will provide a set of rules for "State Machine Specifications" in the Application as well as the matching implementation of the "State Machine Processor" to dispatch events to the HSMs.</dd></dl>
<p><a id="a10_RQP102" name="a10_RQP102"></a> </p><hr  />
<h2><a class="anchor" id="RQP102"></a>
RQP102</h2>
<p><a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support multiple and interchangeable State Machine Implementation Strategies</p>
<dl class="section user"><dt>Amplification</dt><dd><a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Application can choose the State Machine Implementation Strategy (out of a set of supported strategies) through the <em>type</em> of a state machine object. Based on that type, <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall then resolve the matching "State Machine Processor" (matching <em>dispatch</em> method) at run-time. Moreover, <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall allow Applications to add their State Machine Implementation Strategies, and <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall still resolve the matching (application-defined) <em>dispatch</em> method based on the type of the state machine object.</dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>Application-defined State Machine Implementation Strategies might be useful for special purposes, such as components with stringent performance requirements (but perhaps fewer state machine features) or test doubles (in TDD).</dd></dl>
<p><a id="a11_RQP103" name="a11_RQP103"></a> </p><hr  />
<h2><a class="anchor" id="RQP103"></a>
RQP103</h2>
<p><a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall provide a State Machine Implementation Strategy "optimized for manual coding"</p>
<dl class="section user"><dt>Amplification</dt><dd>"Optimized for manual coding" means that changing a single element in the state machine design (e.g., nesting of the state hierarchy) should require changing only a single matching element in the implementation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The State Machine Implementation Strategy "optimized for manual coding" imposes restrictions on the implementation strategy but does <em>not</em> mean that the code must be written manually. In the presence of a modeling tool, such code can also be generated automatically.</dd></dl>
<p><a id="a12_RQP104" name="a12_RQP104"></a> </p><hr  />
<h2><a class="anchor" id="RQP104"></a>
RQP104</h2>
<p><a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework should provide a State Machine Implementation Strategy "optimized for automatic code generation"</p>
<dl class="section user"><dt>Amplification</dt><dd>"Optimized for automatic code generation" means the implementation may contain some redundant information to improve the <em>efficiency</em> of the state machine execution. Also, such a strategy can support <em>more advanced</em> state machine features (see <a class="el" href="srs_sm.html#RQP130">RQP130</a>) than a strategy constrained by the limitations of "manual coding" (see <a class="el" href="srs_sm.html#RQP103">RQP103</a>).</dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>In automatically generated code not intended for manual maintenance, the restrictions of the "manual coding" can be relaxed. In that case, a State Machine Implementation Strategy "optimized for automatic code generation" offers the application developers a choice of higher-performance and/or more features than the strategy "optimized for manual coding." For example, an implementation may contain "transition tables" with information about the chains of state exit and entry actions to execute for a given transition (instead of determining the state exit and entry at run-time). This optimization might require adjusting multiple "transition tables" when changing the hierarchical nesting of a single state, which is considered unsuitable for manual coding (see <a class="el" href="srs_sm.html#RQP103">RQP103</a>). However, optimizations of that kind are trivial for an automatic code generator.</dd></dl>
<p><a id="a13_RQP105" name="a13_RQP105"></a> </p><hr  />
<h2><a class="anchor" id="RQP105"></a>
RQP105</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall be bidirectionally traceable</p>
<dl class="section user"><dt>Amplification</dt><dd>Bi-directional traceability of a State Machine Implementation Strategy means that the rules of the "State Machine Specification" are such that:<ol type="1">
<li>Each state machine element in the <em>design</em> (in the diagram) is represented by exactly one element in the implementation; and</li>
<li>Each state machine element in the <em>implementation</em> corresponds to exactly one element in the design (diagram).</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>Traceability between design and implementation is a required property for many functional safety standards.</dd></dl>
<p><a id="a14_RQP110" name="a14_RQP110"></a> </p><hr  />
<h2><a class="anchor" id="RQP110"></a>
RQP110</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> shall allow Applications to easily access the current event</p>
<dl class="section user"><dt>Amplification</dt><dd>The current event, with its Signal and Parameters, must be available during the RTC processing within the state machine. The access should be computationally inexpensive (e.g., via a pointer).</dd></dl>
<p><a id="a15_RQP111" name="a15_RQP111"></a> </p><hr  />
<h2><a class="anchor" id="RQP111"></a>
RQP111</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> shall allow Applications to easily access the instance variables associated with a given state machine</p>
<dl class="section user"><dt>Amplification</dt><dd>One of the main characteristics of Active Objects is their strict encapsulation. While <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework cannot strictly enforce such encapsulation, the framework should allow the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Application to hide such access from the <em>outside</em> of the AO. At the same time, the framework should allow for easy and computationally inexpensive access to the internal attributes of an Active Object from <em>within</em> the AO, such as from its internal state machine. A good example of implementing such a policy is the concept of class encapsulation in OOP, where the internal attributes are accessible to the class operations (e.g., via the <code>this</code> pointer) and are harder to access from the outside.</dd></dl>
<p><a id="a16_RQP120" name="a16_RQP120"></a> </p><hr  />
<h2><a class="anchor" id="RQP120"></a>
RQP120</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support the state machine features specified in the sub-requirements</p>
<dl class="section user"><dt>Amplification</dt><dd>The state diagram shown in <a class="el" href="srs_sm.html#srs_fig120">Figure. 120</a> below demonstrates a Hierarchical State Machine with all features that need to be supported by all State Machine Implementation Strategies provided in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework:</dd></dl>
<p><a class="anchor" id="srs_fig120"></a></p><div class="image">
<img src="HSM.png" alt=""/>
</div>
  <div class="caption"><center><b>Fig. 120 Hierarchical State Machine diagram with labeled features corresponding to the sub-requirements</b></center></div><dl class="section note"><dt>Note</dt><dd>The hierarchical state machine shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>, demonstrates only a <em>subset</em> of features found in UML Statecharts [5]. Most notably, the UML Statecharts features <b>not</b> supported in the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework include "orthogonal regions" and several kinds of "pseudostates".</dd>
<dd>
Additional, more-advanced features are supported only by the State Machine Implementation Strategy "optimized for automatic code generation", see <a class="el" href="srs_sm.html#RQP130">RQP130</a>.</dd></dl>
<p><a id="a17_RQP120A" name="a17_RQP120A"></a> </p><hr  />
<h2><a class="anchor" id="RQP120A"></a>
RQP120A</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>states</em> capable of holding hierarchically nested substates</p>
<dl class="section user"><dt>Amplification</dt><dd>An example state is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[A]. This is a <em>composite</em> state because it holds other states (called substates). A state that holds no other states is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[A1]. Such a state is called a <em>leaf</em> state. The State Machines Implementation Strategies in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> need to represent both types of states. Moreover, it should be possible to simply add substates to a given state thus making it a composite state as well as remove substates, thus making it a leaf state. Also, it should be possible to simply change the nesting of a given state from one superstate to another (including moving it to the implicit "top" superstate).</dd></dl>
<p><a id="a18_RQP120B" name="a18_RQP120B"></a> </p><hr  />
<h2><a class="anchor" id="RQP120B"></a>
RQP120B</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>entry actions</em> to states</p>
<dl class="section user"><dt>Amplification</dt><dd>Example entry actions to a state are shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[B]. Entry actions to a state are optional, meaning that a given state might specify entry actions or not. If any entry actions are defined in a given state, the State Machine Processor in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> must execute these actions whenever that state is entered. Also, entry actions to superstates must be always executed <em>before</em> entry actions to substates.</dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>Entry actions to a state provide an important mechanism to initialize that state context and <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> must guarantee such initialization on any transition path leading to a given state.</dd></dl>
<p><a id="a19_RQP120C" name="a19_RQP120C"></a> </p><hr  />
<h2><a class="anchor" id="RQP120C"></a>
RQP120C</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>exit actions</em> from states</p>
<dl class="section user"><dt>Amplification</dt><dd>Example exit actions from a state are shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[C]. Exit actions from a state are optional, meaning that a given state might specify exit actions or not. If any exit actions are defined in a given state, the State Machine Processor in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> must execute these actions whenever that state is exited. Also, exit actions to superstates must be always executed <em>after</em> exit actions from substates.</dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>Exit actions from a state provide an important mechanism to cleanup that state context, and <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> must guarantee such cleanup on any transition path leading out of a given state.</dd></dl>
<p><a id="a20_RQP120D" name="a20_RQP120D"></a> </p><hr  />
<h2><a class="anchor" id="RQP120D"></a>
RQP120D</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>nested initial transitions</em> in composite states</p>
<dl class="section user"><dt>Amplification</dt><dd>An example nested initial transition is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[D]. A composite can have at most one initial transition nested directly in that state. The nested initial transition can have actions and can target any direct substate or indirect substate of the parent state (at a deeper level of state nesting). If a given state has an initial transition and other transition (regular or initial) targets that state, <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> must execute the initial transition.</dd></dl>
<dl class="section user"><dt>Initial Transition Execution Sequence</dt><dd>The execution sequence of nested initial transition is as follows:<ol type="1">
<li>actions associated with the initial transition;</li>
<li>entry actions to the target state configuration, starting with the states at the highest levels of nesting;</li>
<li>if the main target state of the initial transition contains its nested initial transition, it should be executed according to the same rules, applied recursively.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>The execution sequence for the initial transition nested directly in state "s2" in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a> is as follows:<br  />
 <code>s2_init(); s22_entry(); s22_init(); s211_entry();</code></dd></dl>
<p>On the other hand, the execution sequence for the initial transition nested directly in state "s1" in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a> is as follows:<br  />
 <code>s1_init(); s12_entry(); s121_entry();</code></p>
<dl class="section note"><dt>Note</dt><dd>It is also legal in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> to have a composite state with substates, but <em>without</em> a nested initial transition. If such a composite state is the main target of a state transition, the state becomes the <em>current state</em>, without any of its substates becoming active.</dd></dl>
<p><a id="a21_RQP120E" name="a21_RQP120E"></a> </p><hr  />
<h2><a class="anchor" id="RQP120E"></a>
RQP120E</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>transitions</em> between states at any level of nesting</p>
<dl class="section user"><dt>Amplification</dt><dd>An example of a transition is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[E]. A transition in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> must have an explicit trigger, which is the <a class="el" href="srs_evt.html#srs_evt_sig">Signal</a> of the event that triggered the transition.</dd></dl>
<dl class="section user"><dt>Main-Source State</dt><dd>The state where the transition originates is called the <em>main-source</em> and in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> this main-source state "owns" the transition. Please note that the main-source state might be different from the current state when the transition is "inherited" from a higher-level state.<br  />
</dd></dl>
<dl class="section user"><dt>Main-Target State</dt><dd>The state where the transition terminates is called the *main-target_. Please note that the main-target state might be different from the new current state after the transition when the main-target state is composite and contains a nested initial transition.</dd></dl>
<dl class="section user"><dt>Self-Transition</dt><dd>In a special case of the main source being the same as the main target (see <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[E1]), the transition is called <em>self-transition</em>.</dd></dl>
<dl class="section user"><dt>Transition Execution Sequence</dt><dd>The execution sequence of a state transition is as follows:<ol type="1">
<li>Actions associated with the transition, which might include the whole <a class="el" href="srs_sm.html#srs_RQP120G_eval">guard evaluation sequence</a>;</li>
<li>Exit actions from the source state configuration, starting with the states at the lowest levels of nesting, up to the <code>LCA(main-source, main-target)</code> state, whereas <code>LCA(s1, s2)</code> denotes the state that is the Least Common Ancestor of states <code>s1</code> and <code>s2</code>, based on the state containment hierarchy.</li>
<li>Entry actions to the target state configuration, starting with the states at the highest levels of nesting. If the main-target state contains a nested initial transition, it should be executed according to the rules described in <a class="el" href="srs_sm.html#RQP120D">RQP120D</a>.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Transition Examples</dt><dd>Assuming that "s222" is the current state, the execution sequence for the transition s22:E2 (see <a class="el" href="srs_sm.html#srs_fig120">Figure 120[E]</a>) is as follows:<br  />
 <code>s22_E2(); s222_exit(); s22_exit(); s2_exit(); s1_entry(); s1_init(); s12_entry(); s121_entry();</code></dd></dl>
<p>Assuming that "s121" is the current state, the execution sequence for the transition s1:E3 (Special Case 1) is as follows:<br  />
 <code>s1_E3(); s121_exit(); s12_exit(); s12_entry(); s121_entry();</code><br  />
</p>
<p>Assuming that "s121" is the current state, the execution sequence for the transition s121:E1 (Special Case 2) is as follows:<br  />
 <code>s121_E2(); s121_exit(); s12_exit(); s1_init(); s12_entry(); s121_entry();</code><br  />
</p>
<p>Assuming that "s222" is the current state, the execution sequence for the self-transition s22:E1 in (see <a class="el" href="srs_sm.html#srs_fig120">Figure 120[E1]</a>) is as follows:<br  />
 <code>s22_E1; s222_exit(); s22_exit(); s22_entry(); s22_init(); s221_entry();</code></p>
<dl class="section note"><dt>Note</dt><dd>In a self-transition, the main-source <b>is</b> exited, and the main-target (same as main-source) <em>is</em> entered. Thus self-transition becomes an idiom for resetting a given state context by cleanly exiting and re-entering a given state.</dd></dl>
<dl class="section user"><dt>Attention</dt><dd>The transition execution sequence in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> <a class="el" href="srs.html#srs_ref">[PSiCC2:08]</a> is <em>different</em> than in the UML Specification <a class="el" href="srs.html#srs_ref">[UML 2.5]</a>, because the <a class="el" href="srs_sm.html#srs_RQP120G_eval">guard evaluation sequence</a> is executed in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> <em>before</em> the exit from the source state configuration and entry to the target state configuration. It is necessary first to determine the main-target state of the transition based on the evaluation of guards. The guards' evaluation might also determine that the event is to be propagated to the higher-level states, or that only an internal transition should be executed, in which cases no states should be exited or entered at all. In the UML Specification [5], transition actions are executed <em>after</em> exiting the source state configuration but <em>before</em> entering the target state configuration, which immensely complicates the semantics and implementation of guards.</dd></dl>
<dl class="section user"><dt>Local State Transition Semantics</dt><dd>In most state transitions, the main-source state is exited, and the main target is entered. The only exceptional cases are explained below:</dd></dl>
<p><em>Special Case 1:</em> If the main-source state of the transition contains the main-target state (e.g., transition E3 in state "s1" in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>), the main-source state is <em>not</em> exited.</p>
<p><em>Special Case 2:</em> If the main-target state contains the main_source (e.g., transition E2 in state "s121" in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>), the main-target is <em>not</em> entered.</p>
<dl class="section note"><dt>Note</dt><dd>In the UML Specification <a class="el" href="srs.html#srs_ref">[UML 2.5]</a>, Special Cases 1 and 2 correspond to the <b>local state transition</b> semantics.</dd></dl>
<p><a id="a22_RQP120F" name="a22_RQP120F"></a> </p><hr  />
<h2><a class="anchor" id="RQP120F"></a>
RQP120F</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>internal transitions</em> in states</p>
<dl class="section user"><dt>Amplification</dt><dd>An example of an internal transition is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[F]. This type of transition causes only the execution of the associated actions. Still, it never leads to a change of the current state, and consequently, it never causes execution of any state exit or state entry actions. An alternative name for internal transition is a *state reaction_. </dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>Internal transitions (state reactions) are very common in practice. Internal transitions are also different from self-transitions because an internal transition never causes execution of any state exit or state entry actions.</dd></dl>
<p><a id="a23_RQP120G" name="a23_RQP120G"></a> </p><hr  />
<h2><a class="anchor" id="RQP120G"></a>
RQP120G</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>guard conditions</em> to be attached to regular and internal transitions</p>
<dl class="section user"><dt>Amplification</dt><dd>An example of a transition with an attached guard condition is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[G]. A <em>guard condition</em> (or simply *guard_) is a Boolean expression that disables a given transition path when it evaluates to FALSE.</dd></dl>
<p>In <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>, guard conditions are always "attached" to a transition via a choice pseudostate (UML Specification [5]). A given choice pseudostate may have multiple attached guards, each starting a separate transition path and associated with its own (optional) action.</p>
<dl class="section user"><dt>Disabled Transitions</dt><dd>If all guards attached to a transition (via a choice pseudostate) evaluate to FALSE, the whole transition is <em>disabled</em>. Such a transition shall be treated as though it was not present, so the triggering event is propagated to the higher-level states in the state hierarchy.</dd></dl>
<p><a class="anchor" id="srs_RQP120G_eval"></a></p><dl class="section user"><dt>Guard Evaluation</dt><dd>Conceptually, you can think of a choice pseudostate and the attached guard conditions as an <code>if-then-else</code> sequence. Each guard is evaluated <em>dynamically</em> when the control reaches the guard in that sequence. For example, the following pseudocode shows the sequence for the transition s2:E2 (<a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[E2]):</dd></dl>
<pre class="fragment">s2_E2();                // action associated with the original transition
if (g1()) {             // evaluate guard g1()
    s2_E2_g1();         // action associated with the path following [g1()]
    transition_to(s1);  // regular state transition
}
else if (g2()) {        // evaluate guard g2()
    s2_E2_g2();         // action associated with the path following [g2()]
    internal_transition(); // internal state transition
}
else {                  // disabled transition
    propagate_to_superstate(top); // event not handled at this level
}
</pre><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="srs_sm.html#srs_RQP120G_eval">guard evaluation sequence</a> determines the <b>main-target</b> of the transition. For example, in the guard evaluation sequence shown above, if the guard <code>g1()</code> evaluates to TRUE, the main target is set to state "s1". Otherwise, if <code>g2()</code> evaluates to TRUE, the main target will not be set, and the <a class="el" href="srs_sm.html#src_sm_proc">State Machine Specification</a> will return status to the <a class="el" href="srs_sm.html#src_sm_proc">QP State Machine Processor</a> to indicate only an <a class="el" href="srs_sm.html#RQP120F">internal transition</a>. Otherwise, if both <code>g1()</code> and <code>g2()</code> evaluate to FALSE, the whole transition is considered <em>disabled</em>, and the <a class="el" href="srs_sm.html#src_sm_proc">State Machine Specification</a> will return status to the <a class="el" href="srs_sm.html#src_sm_proc">QP State Machine Processor</a> to propagate the event to the higher-level state.</dd></dl>
<dl class="section user"><dt>The Complementary [else] Guard</dt><dd><a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> shall also support the special, complementary guard <code>[else]</code> (see <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[G1]), which will explicitly complement all other guards attached to the same choice pseudostate. For example, the following pseudocode shows the sequence for the transition s1:E3 (<a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>):</dd></dl>
<pre class="fragment">s1_E3();                // action associated with the original transition
if (g3()) {             // evaluate guard g3()
    s1_E3_g3();         // action associated with the path following [g3()]
    transition_to_deep_history_of(s22); // transition to history (deep)
}
else {                  // explicit complementary [else] guard
    s1_E3_else();       // action associated with the path following [else]
    transition_to(s21); // regular state transition
}
</pre><p><a id="a24_RQP120I" name="a24_RQP120I"></a> </p><hr  />
<h2><a class="anchor" id="RQP120I"></a>
RQP120I</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework shall support <em>top-most initial transition</em> that shall be explicitly triggered independently from instantiation of the state machine object</p>
<dl class="section user"><dt>Amplification</dt><dd>An example top-most initial transition is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[I]. The top-most initial transition has the same semantics as nested initial transitions (see <a class="el" href="srs_sm.html#RQP120D">RQP120D</a>) except the top-most initial transition nests in the implicit "top" superstate and it is mandatory rather than optional.</dd></dl>
<p>The execution of the top-most initial transition is intentionally separated from the instantiation of the state machine object, to allow applications to fully control the initialization performed in the actions to the top-most initial transition.</p>
<dl class="section user"><dt>Rationale</dt><dd>The instantiation of state machine objects might occur in an undefined order, even before the entry point into the application (before the <code>main()</code> function in C++). This is typically before the target hardware or the underlying real-time kernel has been properly initialized.</dd></dl>
<p><a id="a25_RQP120H" name="a25_RQP120H"></a> </p><hr  />
<h2><a class="anchor" id="RQP120H"></a>
RQP120H</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework should support <em>transitions to history</em>; Both shallow and deep histories shall be supported</p>
<dl class="section user"><dt>Amplification</dt><dd>An example of a transition to <em>deep history</em> is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[H1]. An example of a transition path to <em>shallow history</em> is shown in <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[H2]. Transitions to history (deep or shallow) apply only to composite states and represent the most recently active substate. In the case of deep history, the actual current substate is remembered upon the exit from the given composite state. In the case of shallow history, only the direct substate containing the current substate is remembered. Transition to state history means transitioning to that remembered substate. Upon initialization, when a given composite state has never been active before, the transition to history is initialized with the <em>default history</em>, which is the substate pointed to by the transition coming out of the history circle (e.g., <a class="el" href="srs_sm.html#srs_fig120">Figure 120</a>[H1]).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>To support transitions to history, <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework needs to supply a mechanism to access the current state (deep history) and the direct substate of the current state. This information needs to be stored upon the exit of a given composite state. Also, the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework needs to transition dynamically to the stored history substate.</dd></dl>
<p><a id="a26_RQP120S" name="a26_RQP120S"></a> </p><hr  />
<h2><a class="anchor" id="RQP120S"></a>
RQP120S</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework might supply a method for checking if a state machine is in a given state</p>
<dl class="section user"><dt>Amplification</dt><dd>The "is-in" state operation returns TRUE if the current state of the state machine is equal or is a substate of the given state. Otherwise, the "is-in" operation returns FALSE.</dd></dl>
<dl class="section user"><dt>Intent</dt><dd>This operation is intended to be used only for state machines that run in the same thread of execution. For example, a given Active Object could use the "is-in" check on one of the "Orthogonal Components" owned by that Active Object.</dd></dl>
<p><a id="a27_RQP120T" name="a27_RQP120T"></a> </p><hr  />
<h2><a class="anchor" id="RQP120T"></a>
RQP120T</h2>
<p>All State Machine Implementation Strategies provided by <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework might supply the <em>top-state</em></p>
<dl class="section user"><dt>Amplification</dt><dd>The <em>top-state</em> is the ultimate root of state hierarchy and typically it is not rendered in the state diagrams. However, the concept can be useful in State Machine Specification as the superstate of states not nested in any other state. In case a given State Machine Implementation Strategy uses the concept of the top-state, <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework may provide a top-state element with the default behavior of silently ignoring all events.</dd></dl>
<p><a id="a28_RQP130" name="a28_RQP130"></a> </p><hr  />
<h2><a class="anchor" id="RQP130"></a>
RQP130</h2>
<p>State Machine Implementation Strategy "optimized for automatic code generation" should support reuse of behavior via <em>submachines</em></p>
<dl class="section user"><dt>Amplification</dt><dd>A <em>submachine</em> is a composite state with all its nested substates and transitions packaged as a unit (submachine). This unit can then be instantiated inside a given state machine multiple times, wherever that particular composite state is needed. Each instance of a submachine is called <em>submachine-state</em>.</dd></dl>
<dl class="section user"><dt>Rationale</dt><dd>Submachines are an important mechanism of reusing behavior inside state machines, similar to "macros" or "subroutines" in programming languages. A one-time definition of the submachine corresponds in this analogy to a "subroutine" definition. Each instance of the submachine corresponds to a "subroutine call".</dd></dl>
<p>To package a composite state as a unit (submachine), the submachine needs to provide a well-defined interface to the other parts of the state machine. This formal interface consists of <em>entry segments</em>, <em>exit points</em>, and <em>history segments</em> (<a class="el" href="srs_sm.html#srs_fig130">Figure 130</a>[B,C,D]).</p>
<dl class="section note"><dt>Note</dt><dd>Submachines should <b>not</b> be confused with concurrently-active "orthogonal regions".</dd></dl>
<p><a class="anchor" id="srs_fig130"></a></p><div class="image">
<img src="MSM_sub.png" alt=""/>
</div>
  <div class="image">
<img src="MSM.png" alt=""/>
</div>
  <div class="caption"><center><b>Figure 130 Submachine diagram (top) and State machine diagram with submachine-state (bottom). The labeled features corresponding to the sub-requirements</b></center></div><p><a id="a29_RQP130A" name="a29_RQP130A"></a> </p><hr  />
<h2><a class="anchor" id="RQP130A"></a>
RQP130A</h2>
<p>State Machine Implementation Strategy "optimized for automatic code generation" should allow applications to add multiple submachines to a given hierarchical state machine</p>
<dl class="section user"><dt>Amplification</dt><dd>A submachine, similar to a composite state, can have its own entry actions and exit actions as well as an initial transition nested directly in this submachine.</dd></dl>
<p>A submachine added to a given host hierarchical state machine shall operate in the same context as the host state machine. In particular, the submachine shall have access to the same attributes as the host state machine.</p>
<dl class="section user"><dt>Rationale</dt><dd>Submachines and their interfaces are typically difficult to implement within the constraints of <a class="el" href="srs_sm.html#RQP103">manual coding</a>. Therefore, the requirement for supporting submachines is limited to the State Machine Implementation Strategy <a class="el" href="srs_sm.html#RQP104">optimized for automatic code generation</a>.</dd></dl>
<p><a id="a30_RQP130B" name="a30_RQP130B"></a> </p><hr  />
<h2><a class="anchor" id="RQP130B"></a>
RQP130B</h2>
<p>The submachines should support <em>entry points</em></p>
<dl class="section user"><dt>Amplification</dt><dd>An example of an <em>entry segment</em> is shown in <a class="el" href="srs_sm.html#srs_fig130">Figure 130</a>[B]. An entry segment needs to have a name (unique within a given submachine) and needs to target a substate of a given submachine. An entry segment might also have actions to be executed after the submachine is entered, before any other actions in the submachine (such as submachine's entry action or any nested initial transition.)</dd></dl>
<p><a id="a31_RQP130C" name="a31_RQP130C"></a> </p><hr  />
<h2><a class="anchor" id="RQP130C"></a>
RQP130C</h2>
<p>The submachines should support <em>exit points</em></p>
<dl class="section user"><dt>Amplification</dt><dd>An example of an <em>exit point</em> is shown in <a class="el" href="srs_sm.html#srs_fig130">Figure 130</a>[C]. An exit point needs to have a name (unique within a given submachine) and its purpose is to provide a termination point for all state transitions that exit the submachine. Exit points don't have actions of their own.</dd></dl>
<p><a id="a32_RQP130D" name="a32_RQP130D"></a> </p><hr  />
<h2><a class="anchor" id="RQP130D"></a>
RQP130D</h2>
<p>The submachines should support <em>history segments</em>. Both shallow and deep histories shall be supported.</p>
<dl class="section user"><dt>Amplification</dt><dd>An example of an <em>history segment</em> is shown in <a class="el" href="srs_sm.html#srs_fig130">Figure 130</a>[D]. History segments (deep or shallow) shall operate similarly as <a class="el" href="srs_sm.html#RQP120H">transitions to history</a> in composite states.</dd></dl>
<p><a id="a33_RQP130E" name="a33_RQP130E"></a> </p><hr  />
<h2><a class="anchor" id="RQP130E"></a>
RQP130E</h2>
<p>State Machine Implementation Strategy "optimized for automatic code generation" should support <em>submachine-states</em></p>
<dl class="section user"><dt>Amplification</dt><dd>An example of an <em>submachine state</em> is shown in <a class="el" href="srs_sm.html#srs_fig130">Figure 130</a>[E]. A submachine state is an instance of the given submachine placed in a specific context of the host hierarchical state machine. The context is established by the connections made to the interface of the submachine exposed by the submachine state. Specifically, the context of a submachine state consists of the incoming transitions that terminate on the specific entry points and by exit segments originating on the specific exit points. Additionally, a submachine state can have its own transitions originating on its boundary and terminating on its boundary.</dd></dl>
<p><a id="a34_RQP130F" name="a34_RQP130F"></a> </p><hr  />
<h2><a class="anchor" id="RQP130F"></a>
RQP130F</h2>
<p>State Machine Implementation Strategy "optimized for automatic code generation" should support <em>exit segments</em></p>
<dl class="section user"><dt>Amplification</dt><dd>An example of an <em>xit segments</em> is shown in <a class="el" href="srs_sm.html#srs_fig130">Figure 130</a>[F]. An exit segment is similar to a transition, except it does not have a trigger, but instead it attaches to a given exit point of a submachine state.</dd></dl>
<p><span class="prev_button"><a class="el" href="srs_evt.html">Events</a></span><span class="next_button"><a class="el" href="srs_ao.html">Active Objects</a></span>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="srs.html">Requirements (SRS)</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
