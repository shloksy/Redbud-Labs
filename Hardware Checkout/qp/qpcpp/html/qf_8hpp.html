<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: qf.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C++
    &nbsp;<span id="projectnumber">7.2.1</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('qf_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">qf.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>QF/C++ platform-independent public interface.
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;new&gt;</code><br />
<code>#include &lt;cstdarg&gt;</code><br />
</div>
<p><a href="qf_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_p_set.html">QPSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority Set of up to <a class="el" href="qf__port_8hpp.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> elements.  <a href="class_q_p_1_1_q_p_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_active.html">QActive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_q_p_1_1_q_active.html" title="QP::QActive active object class (based on the QP::QHsm-style implementation strategy)">QP::QActive</a> active object class (based on the <a class="el" href="class_q_p_1_1_q_hsm.html" title="Hierarchical State Machine abstract base class (ABC)">QP::QHsm</a>-style implementation strategy)  <a href="class_q_p_1_1_q_active.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_m_active.html">QMActive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_q_p_1_1_q_m_active.html" title="QMActive active object (based on QP::QMsm implementation)">QMActive</a> active object (based on <a class="el" href="class_q_p_1_1_q_msm.html" title="QM State Machine implementation strategy.">QP::QMsm</a> implementation)  <a href="class_q_p_1_1_q_m_active.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_time_evt.html">QTimeEvt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time Event class (inherits <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>:<a class="el" href="class_q_p_1_1_q_evt.html" title="Event class.">QEvt</a>)  <a href="class_q_p_1_1_q_time_evt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_p_1_1_q_ticker.html">QTicker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Ticker" Active Object class (inherits <a class="el" href="class_q_p_1_1_q_active.html" title="QP::QActive active object class (based on the QP::QHsm-style implementation strategy)">QP::QActive</a>)  <a href="class_q_p_1_1_q_ticker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_q_p"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p.html">QP</a></td></tr>
<tr class="memdesc:namespace_q_p"><td class="mdescLeft">&#160;</td><td class="mdescRight">QP/C++ framework. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_q_p_1_1_q_f"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html">QP::QF</a></td></tr>
<tr class="memdesc:namespace_q_p_1_1_q_f"><td class="mdescLeft">&#160;</td><td class="mdescRight">hierarchical event processor and active object framework <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac652bd9796be02f0e71af57b9a0b6a85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#ac652bd9796be02f0e71af57b9a0b6a85">Q_PRIO</a>(prio_,  pthre_)&#160;&#160;&#160;(static_cast&lt;<a class="el" href="namespace_q_p.html#ad20484546ff0c81339a859337bb00613">QP::QPrioSpec</a>&gt;((prio_) | (pthre_) &lt;&lt; 8U))</td></tr>
<tr class="memdesc:ac652bd9796be02f0e71af57b9a0b6a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="namespace_q_p.html#ad20484546ff0c81339a859337bb00613" title="Priority specification for Active Objects in QP.">QP::QPrioSpec</a> object to specify priority of an AO or a thread.  <br /></td></tr>
<tr class="separator:ac652bd9796be02f0e71af57b9a0b6a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85513d80fc73d015efff2596428e4703"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#a85513d80fc73d015efff2596428e4703">Q_NEW</a>(evtT_,  sig_, ...)</td></tr>
<tr class="memdesc:a85513d80fc73d015efff2596428e4703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a dynamic event (case when <a class="el" href="class_q_p_1_1_q_evt.html" title="Event class.">QP::QEvt</a> is not a POD)  <br /></td></tr>
<tr class="separator:a85513d80fc73d015efff2596428e4703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190067e72a37774fa0ecfc84dba14615"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#a190067e72a37774fa0ecfc84dba14615">Q_NEW_X</a>(e_,  evtT_,  margin_,  sig_, ...)</td></tr>
<tr class="memdesc:a190067e72a37774fa0ecfc84dba14615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-asserting allocate a dynamic event (case when <a class="el" href="class_q_p_1_1_q_evt.html" title="Event class.">QP::QEvt</a> is not a POD)  <br /></td></tr>
<tr class="separator:a190067e72a37774fa0ecfc84dba14615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0">Q_NEW_REF</a>(evtRef_,  evtT_)&#160;&#160;&#160;    ((evtRef_) = static_cast&lt;evtT_ const *&gt;(<a class="el" href="namespace_q_p_1_1_q_f.html#acc01bf7f20f6517953de5ef28af442fb">QP::QF::newRef_</a>(e, (evtRef_))))</td></tr>
<tr class="memdesc:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new reference of the current event <code>e</code>  <br /></td></tr>
<tr class="separator:a10162978b156ab5d2fd2e3a7aa744ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed009a86c52cf2b8d811389fabb5f23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23">Q_DELETE_REF</a>(evtRef_)</td></tr>
<tr class="memdesc:aaed009a86c52cf2b8d811389fabb5f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the event reference.  <br /></td></tr>
<tr class="separator:aaed009a86c52cf2b8d811389fabb5f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac809aab93c0c4cb303ecc39b8e3825e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#ac809aab93c0c4cb303ecc39b8e3825e2">PUBLISH</a>(e_,  sender_)&#160;&#160;&#160;    publish_((e_), (sender_), (sender_)-&gt;getPrio())</td></tr>
<tr class="memdesc:ac809aab93c0c4cb303ecc39b8e3825e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the event publishing facility QActive::publish_().  <br /></td></tr>
<tr class="separator:ac809aab93c0c4cb303ecc39b8e3825e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e898fd379bdf4753e803b10d2c6f8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#a46e898fd379bdf4753e803b10d2c6f8f">POST</a>(e_,  sender_)&#160;&#160;&#160;post_((e_), <a class="el" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034">QP::QF::NO_MARGIN</a>, (sender_))</td></tr>
<tr class="memdesc:a46e898fd379bdf4753e803b10d2c6f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the direct event posting facility QActive::post_()  <br /></td></tr>
<tr class="separator:a46e898fd379bdf4753e803b10d2c6f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae774afb3828695a8e6c5797de441dd2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#ae774afb3828695a8e6c5797de441dd2e">POST_X</a>(e_,  margin_,  sender_)&#160;&#160;&#160;    post_((e_), (margin_), (sender_))</td></tr>
<tr class="memdesc:ae774afb3828695a8e6c5797de441dd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the direct event posting facility QActive::post_() without delivery guarantee.  <br /></td></tr>
<tr class="separator:ae774afb3828695a8e6c5797de441dd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a12c5b2f250d8d874a2ec0ba72a0676"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#a9a12c5b2f250d8d874a2ec0ba72a0676">TICK_X</a>(tickRate_,  sender_)&#160;&#160;&#160;tick_((tickRate_), (sender_))</td></tr>
<tr class="memdesc:a9a12c5b2f250d8d874a2ec0ba72a0676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing QTimeEvt::tick_()  <br /></td></tr>
<tr class="separator:a9a12c5b2f250d8d874a2ec0ba72a0676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb95c078f4da69732d4bfee44e3c52e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#acb95c078f4da69732d4bfee44e3c52e4">TICK</a>(sender_)&#160;&#160;&#160;<a class="el" href="qf_8hpp.html#a9a12c5b2f250d8d874a2ec0ba72a0676">TICK_X</a>(0U, (sender_))</td></tr>
<tr class="memdesc:acb95c078f4da69732d4bfee44e3c52e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing for rate 0.  <br /></td></tr>
<tr class="separator:acb95c078f4da69732d4bfee44e3c52e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#adc8820f52d450bcfb7d1f830e6c8a8c2">QF_CRIT_EXIT_NOP</a>()&#160;&#160;&#160;(static_cast&lt;void&gt;(0))</td></tr>
<tr class="memdesc:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-operation for exiting a critical section.  <br /></td></tr>
<tr class="separator:adc8820f52d450bcfb7d1f830e6c8a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a74a52dba7c96d165eb04cc6e90bc0fd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p.html#a74a52dba7c96d165eb04cc6e90bc0fd6">QPSetBits</a> = std::uint32_t</td></tr>
<tr class="separator:a74a52dba7c96d165eb04cc6e90bc0fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad820d9cf36214223f124bc2b606eeb10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p.html#ad820d9cf36214223f124bc2b606eeb10">QTimeEvtCtr</a> = std::uint32_t</td></tr>
<tr class="separator:ad820d9cf36214223f124bc2b606eeb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20484546ff0c81339a859337bb00613"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p.html#ad20484546ff0c81339a859337bb00613">QPrioSpec</a> = std::uint16_t</td></tr>
<tr class="memdesc:ad20484546ff0c81339a859337bb00613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority specification for Active Objects in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>.  <br /></td></tr>
<tr class="separator:ad20484546ff0c81339a859337bb00613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12593f01db10e70006a52dc4a5c0cc60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p.html#a12593f01db10e70006a52dc4a5c0cc60">QSchedStatus</a> = std::uint_fast16_t</td></tr>
<tr class="memdesc:a12593f01db10e70006a52dc4a5c0cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scheduler lock status used in some real-time kernels.  <br /></td></tr>
<tr class="separator:a12593f01db10e70006a52dc4a5c0cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf70f82ef06023008c568e80e1e85ad9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p.html#abf70f82ef06023008c568e80e1e85ad9">QSubscrList</a> = QPSet</td></tr>
<tr class="memdesc:abf70f82ef06023008c568e80e1e85ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscriber List (for publish-subscribe)  <br /></td></tr>
<tr class="separator:abf70f82ef06023008c568e80e1e85ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr class="memdesc:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> initialization.  <br /></td></tr>
<tr class="separator:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c528baf37154d347366083f0f816846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a8c528baf37154d347366083f0f816846">stop</a> ()</td></tr>
<tr class="memdesc:a8c528baf37154d347366083f0f816846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> application and return control to the OS/Kernel.  <br /></td></tr>
<tr class="separator:a8c528baf37154d347366083f0f816846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938249408b2c41a001b202cf9ab3b6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a938249408b2c41a001b202cf9ab3b6fd">run</a> ()</td></tr>
<tr class="memdesc:a938249408b2c41a001b202cf9ab3b6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> to run the application.  <br /></td></tr>
<tr class="separator:a938249408b2c41a001b202cf9ab3b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe6b9a07bf7ed9a924b042c3bcc8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#af8fe6b9a07bf7ed9a924b042c3bcc8a5">onStartup</a> ()</td></tr>
<tr class="memdesc:af8fe6b9a07bf7ed9a924b042c3bcc8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> callback (defined in applications/ports)  <br /></td></tr>
<tr class="separator:af8fe6b9a07bf7ed9a924b042c3bcc8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328327af4c61c92fe5f6d9786d8b90c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a328327af4c61c92fe5f6d9786d8b90c1">onCleanup</a> ()</td></tr>
<tr class="memdesc:a328327af4c61c92fe5f6d9786d8b90c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> callback (defined in applications/ports)  <br /></td></tr>
<tr class="separator:a328327af4c61c92fe5f6d9786d8b90c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2661f3a8d818b3e3eebaabda9b4ced5a"><td class="memItemLeft" align="right" valign="top">std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a2661f3a8d818b3e3eebaabda9b4ced5a">getQueueMin</a> (std::uint_fast8_t const prio) noexcept</td></tr>
<tr class="memdesc:a2661f3a8d818b3e3eebaabda9b4ced5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the minimum of free entries of the given event queue of an active object (indicated by priority <code>prio</code>)  <br /></td></tr>
<tr class="separator:a2661f3a8d818b3e3eebaabda9b4ced5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26009462ff1baafe3c177c8118f874d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a26009462ff1baafe3c177c8118f874d2">psInit</a> (QSubscrList *const subscrSto, <a class="el" href="qep_8hpp.html#a17507c4fc030f571427f3a79e83d4277">enum_t</a> const maxSignal) noexcept</td></tr>
<tr class="memdesc:a26009462ff1baafe3c177c8118f874d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <br /></td></tr>
<tr class="separator:a26009462ff1baafe3c177c8118f874d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b38af4b7b4aecc95b1a36d141e873a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#af3b38af4b7b4aecc95b1a36d141e873a">publish_</a> (QEvt const *const e, void const *const sender, std::uint_fast8_t const qs_id) noexcept</td></tr>
<tr class="memdesc:af3b38af4b7b4aecc95b1a36d141e873a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to all subscribers of a given signal <code>e-&gt;sig</code>  <br /></td></tr>
<tr class="separator:af3b38af4b7b4aecc95b1a36d141e873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961322593bf7e0d7821e1bd7b4f5f6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a961322593bf7e0d7821e1bd7b4f5f6b0">tick_</a> (std::uint_fast8_t const tickRate, void const *const sender) noexcept</td></tr>
<tr class="memdesc:a961322593bf7e0d7821e1bd7b4f5f6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <br /></td></tr>
<tr class="separator:a961322593bf7e0d7821e1bd7b4f5f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81f33393cd2fe6390bd451dad555545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#ab81f33393cd2fe6390bd451dad555545">poolInit</a> (void *const poolSto, std::uint_fast32_t const poolSize, std::uint_fast16_t const evtSize) noexcept</td></tr>
<tr class="memdesc:ab81f33393cd2fe6390bd451dad555545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <br /></td></tr>
<tr class="separator:ab81f33393cd2fe6390bd451dad555545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f78ae7178a02a2bb60889d413c6df4"><td class="memItemLeft" align="right" valign="top">QEvt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a96f78ae7178a02a2bb60889d413c6df4">newX_</a> (std::uint_fast16_t const evtSize, std::uint_fast16_t const margin, <a class="el" href="qep_8hpp.html#a17507c4fc030f571427f3a79e83d4277">enum_t</a> const sig) noexcept</td></tr>
<tr class="memdesc:a96f78ae7178a02a2bb60889d413c6df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> implementation of creating new dynamic mutable event.  <br /></td></tr>
<tr class="separator:a96f78ae7178a02a2bb60889d413c6df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f70fa40bdb5a9ed3524c5309be685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a7d5f70fa40bdb5a9ed3524c5309be685">gc</a> (QEvt const *const e) noexcept</td></tr>
<tr class="memdesc:a7d5f70fa40bdb5a9ed3524c5309be685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <br /></td></tr>
<tr class="separator:a7d5f70fa40bdb5a9ed3524c5309be685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2404cde36d1b1209a1cf894fcdd79f"><td class="memItemLeft" align="right" valign="top">std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a8b2404cde36d1b1209a1cf894fcdd79f">poolGetMaxBlockSize</a> () noexcept</td></tr>
<tr class="memdesc:a8b2404cde36d1b1209a1cf894fcdd79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the block size of any registered event pools.  <br /></td></tr>
<tr class="separator:a8b2404cde36d1b1209a1cf894fcdd79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc01bf7f20f6517953de5ef28af442fb"><td class="memItemLeft" align="right" valign="top">QEvt const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#acc01bf7f20f6517953de5ef28af442fb">newRef_</a> (QEvt const *const e, QEvt const *const evtRef) noexcept</td></tr>
<tr class="memdesc:acc01bf7f20f6517953de5ef28af442fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> implementation of creating new event reference.  <br /></td></tr>
<tr class="separator:acc01bf7f20f6517953de5ef28af442fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a52e38f626220d0568f56446bb09c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a89a52e38f626220d0568f56446bb09c7">deleteRef_</a> (QEvt const *const evtRef) noexcept</td></tr>
<tr class="memdesc:a89a52e38f626220d0568f56446bb09c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> implementation of deleting event reference.  <br /></td></tr>
<tr class="separator:a89a52e38f626220d0568f56446bb09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a7c81ff3770d311e78876574dfd0f8"><td class="memItemLeft" align="right" valign="top">std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a10a7c81ff3770d311e78876574dfd0f8">getPoolMin</a> (std::uint_fast8_t const poolId) noexcept</td></tr>
<tr class="memdesc:a10a7c81ff3770d311e78876574dfd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the minimum of free entries of the given event pool.  <br /></td></tr>
<tr class="separator:a10a7c81ff3770d311e78876574dfd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b03905caeba6d995816003374e3717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8hpp.html#aa5b03905caeba6d995816003374e3717">QF_onContextSw</a> (<a class="el" href="class_q_p_1_1_q_active.html">QP::QActive</a> *prev, <a class="el" href="class_q_p_1_1_q_active.html">QP::QActive</a> *next)</td></tr>
<tr class="memdesc:aa5b03905caeba6d995816003374e3717"><td class="mdescLeft">&#160;</td><td class="mdescRight">QF context switch callback used in built-in kernels.  <br /></td></tr>
<tr class="separator:aa5b03905caeba6d995816003374e3717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a411345fbc8d3502ee62bd80cc607376b"><td class="memItemLeft" align="right" valign="top">std::uint_fast8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a411345fbc8d3502ee62bd80cc607376b">intLock_</a></td></tr>
<tr class="memdesc:a411345fbc8d3502ee62bd80cc607376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt lock up-down counter (used in some <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> ports)  <br /></td></tr>
<tr class="separator:a411345fbc8d3502ee62bd80cc607376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03f48742df08a06b203ef53de9409da"><td class="memItemLeft" align="right" valign="top">std::uint_fast8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#ac03f48742df08a06b203ef53de9409da">intNest_</a></td></tr>
<tr class="memdesc:ac03f48742df08a06b203ef53de9409da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt nesting up-down counter (used in some <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> ports)  <br /></td></tr>
<tr class="separator:ac03f48742df08a06b203ef53de9409da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75157d4683e3ffe18bbd169033a7c034"><td class="memItemLeft" align="right" valign="top">constexpr std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034">NO_MARGIN</a> {0xFFFFU}</td></tr>
<tr class="memdesc:a75157d4683e3ffe18bbd169033a7c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value of margin that causes asserting failure in case event allocation or event posting fails.  <br /></td></tr>
<tr class="separator:a75157d4683e3ffe18bbd169033a7c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac652bd9796be02f0e71af57b9a0b6a85" name="ac652bd9796be02f0e71af57b9a0b6a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac652bd9796be02f0e71af57b9a0b6a85">&#9670;&#160;</a></span>Q_PRIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_PRIO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pthre_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(static_cast&lt;<a class="el" href="namespace_q_p.html#ad20484546ff0c81339a859337bb00613">QP::QPrioSpec</a>&gt;((prio_) | (pthre_) &lt;&lt; 8U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01596">1596</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a85513d80fc73d015efff2596428e4703" name="a85513d80fc73d015efff2596428e4703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85513d80fc73d015efff2596428e4703">&#9670;&#160;</a></span>Q_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<span class="keyword">new</span>(<a class="code hl_function" href="namespace_q_p_1_1_q_f.html#a96f78ae7178a02a2bb60889d413c6df4">QP::QF::newX_</a>(<span class="keyword">sizeof</span>(evtT_), <a class="code hl_variable" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034">QP::QF::NO_MARGIN</a>, (sig_))) \</div>
<div class="line">        evtT_((sig_),  ##__VA_ARGS__))</div>
<div class="ttc" id="anamespace_q_p_1_1_q_f_html_a75157d4683e3ffe18bbd169033a7c034"><div class="ttname"><a href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034">QP::QF::NO_MARGIN</a></div><div class="ttdeci">constexpr std::uint_fast16_t NO_MARGIN</div><div class="ttdoc">Special value of margin that causes asserting failure in case event allocation or event posting fails...</div><div class="ttdef"><b>Definition:</b> <a href="qf_8hpp_source.html#l01383">qf.hpp:1383</a></div></div>
<div class="ttc" id="anamespace_q_p_1_1_q_f_html_a96f78ae7178a02a2bb60889d413c6df4"><div class="ttname"><a href="namespace_q_p_1_1_q_f.html#a96f78ae7178a02a2bb60889d413c6df4">QP::QF::newX_</a></div><div class="ttdeci">QEvt * newX_(std::uint_fast16_t const evtSize, std::uint_fast16_t const margin, enum_t const sig) noexcept</div><div class="ttdoc">Internal QF implementation of creating new dynamic mutable event.</div><div class="ttdef"><b>Definition:</b> <a href="qf__dyn_8cpp_source.html#l00125">qf_dyn.cpp:125</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01628">1628</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a190067e72a37774fa0ecfc84dba14615" name="a190067e72a37774fa0ecfc84dba14615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190067e72a37774fa0ecfc84dba14615">&#9670;&#160;</a></span>Q_NEW_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">margin_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">    (e_) = <span class="keyword">static_cast&lt;</span>evtT_ *<span class="keyword">&gt;</span>( \</div>
<div class="line">              <a class="code hl_function" href="namespace_q_p_1_1_q_f.html#a96f78ae7178a02a2bb60889d413c6df4">QP::QF::newX_</a>(<span class="keyword">sizeof</span>(evtT_), (margin_), (sig_))); \</div>
<div class="line">    if ((e_) != <span class="keyword">nullptr</span>) { \</div>
<div class="line">        new((e_)) evtT_((sig_),  ##__VA_ARGS__); \</div>
<div class="line">    } \</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01670">1670</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a10162978b156ab5d2fd2e3a7aa744ac0" name="a10162978b156ab5d2fd2e3a7aa744ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10162978b156ab5d2fd2e3a7aa744ac0">&#9670;&#160;</a></span>Q_NEW_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_NEW_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtRef_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ((evtRef_) = static_cast&lt;evtT_ const *&gt;(<a class="el" href="namespace_q_p_1_1_q_f.html#acc01bf7f20f6517953de5ef28af442fb">QP::QF::newRef_</a>(e, (evtRef_))))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The current event processed by an active object is available only for the duration of the run-to-completion (RTC) step. After that step, the current event is no longer available and the framework might recycle (garbage-collect) the event. The macro <a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> explicitly creates a new reference to the current event that can be stored and used beyond the current RTC step, until the reference is explicitly recycled by means of the macro <a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">evtRef_</td><td>event reference to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtT_</td><td>event type (class name) of the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The example <b>defer</b> in the directory <code>examples/win32/defer</code> illustrates the use of <a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01699">1699</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="aaed009a86c52cf2b8d811389fabb5f23" name="aaed009a86c52cf2b8d811389fabb5f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed009a86c52cf2b8d811389fabb5f23">&#9670;&#160;</a></span>Q_DELETE_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_DELETE_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtRef_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">    QP::QF::deleteRef_((evtRef_)); \</div>
<div class="line">    (evtRef_) = 0U; \</div>
<div class="line">} <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment --><p>Every event reference created with the macro <a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> needs to be eventually deleted by means of the macro <a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a> to avoid leaking the event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">evtRef_</td><td>event reference to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Usage</dt><dd>The example <b>defer</b> in the directory <code>examples/win32/defer</code> illustrates the use of <a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01717">1717</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="ac809aab93c0c4cb303ecc39b8e3825e2" name="ac809aab93c0c4cb303ecc39b8e3825e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac809aab93c0c4cb303ecc39b8e3825e2">&#9670;&#160;</a></span>PUBLISH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUBLISH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    publish_((e_), (sender_), (sender_)-&gt;getPrio())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro is the recommended way of publishing events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the posted event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object (actually used only when <a class="el" href="config_8hpp.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pointer to the <code>sender_</code> object is not necessarily a pointer to an active object. In fact, if QActive::PUBLISH() is called from an interrupt or other context, you can create a unique object just to unambiguously identify the sender of the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QActive::publish_() </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01742">1742</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a46e898fd379bdf4753e803b10d2c6f8f" name="a46e898fd379bdf4753e803b10d2c6f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e898fd379bdf4753e803b10d2c6f8f">&#9670;&#160;</a></span>POST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;post_((e_), <a class="el" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034">QP::QF::NO_MARGIN</a>, (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro asserts if the queue overflows and cannot accept the event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the event to post </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sendedr_</code> parameter is actually only used when QS tracing is enabled (macro <a class="el" href="config_8hpp.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disenabled, the <a class="el" href="qf_8hpp.html#a46e898fd379bdf4753e803b10d2c6f8f" title="Invoke the direct event posting facility QActive::post_()">POST()</a> macro does not pass the <code>sender_</code> parameter, </dd>
<dd>
the pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qf_8hpp.html#a46e898fd379bdf4753e803b10d2c6f8f" title="Invoke the direct event posting facility QActive::post_()">POST()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the sender of the event.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QActive::post_() </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01774">1774</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="ae774afb3828695a8e6c5797de441dd2e" name="ae774afb3828695a8e6c5797de441dd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae774afb3828695a8e6c5797de441dd2e">&#9670;&#160;</a></span>POST_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POST_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">margin_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    post_((e_), (margin_), (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro does not assert if the queue overflows and cannot accept the event with the specified margin of free slots remaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e_</td><td>pointer to the event to post </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin_</td><td>the minimum free slots in the queue, which must still be available after posting the event. The special value QF::NO_MARGIN causes asserting failure in case event posting fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the posting succeeded, and 'false' if the posting failed due to insufficient margin of free entries available in the queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>sender_</code> parameter is actually only used when QS tracing is enabled (macro <a class="el" href="config_8hpp.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined). When QS software tracing is disabled, the <a class="el" href="qf_8hpp.html#ae774afb3828695a8e6c5797de441dd2e" title="Invoke the direct event posting facility QActive::post_() without delivery guarantee.">POST_X()</a> macro does not pass the <code>sender_</code> parameter, so the overhead of passing this extra parameter is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, if <a class="el" href="qf_8hpp.html#ae774afb3828695a8e6c5797de441dd2e" title="Invoke the direct event posting facility QActive::post_() without delivery guarantee.">POST_X()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the sender of the event.</dd></dl>
<dl class="section user"><dt>Usage</dt><dd><div class="fragment"><div class="line"><span class="keyword">extern</span> QActive *AO_Table;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7">Q_STATE_DEF</a>(Philo, hungry) {</div>
<div class="line">    <a class="code hl_typedef" href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a> status_;</div>
<div class="line">    <span class="keywordflow">switch</span> (e-&gt;sig) {</div>
<div class="line">        <span class="keywordflow">case</span> Q_ENTRY_SIG: {</div>
<div class="line">            TableEvt *pe = <a class="code hl_define" href="qf_8hpp.html#a190067e72a37774fa0ecfc84dba14615">Q_NEW_X</a>(TableEvt, 5U, <span class="comment">/* &lt;- margin */</span></div>
<div class="line">                                   HUNGRY_SIG);</div>
<div class="line">            <span class="keywordflow">if</span> (te != <span class="keyword">nullptr</span>) {</div>
<div class="line">                pe-&gt;philoNum = PHILO_ID(<span class="keyword">this</span>);</div>
<div class="line">                AO_Table-&gt;POST_X(pe, 2U, <span class="keyword">this</span>); <span class="comment">// &lt;----</span></div>
<div class="line">            }</div>
<div class="line">            status_ = Q_RET_HANDLED;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        . . .</div>
<div class="line">        <span class="keywordflow">default</span>: {</div>
<div class="line">            status_ = super(&amp;top);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> status_;</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_q_p_html_a12b7ba71c9618c6aa0e435ab8607f81f"><div class="ttname"><a href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a></div><div class="ttdeci">std::uint_fast8_t QState</div><div class="ttdoc">Type returned from state-handler functions.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00209">qep.hpp:209</a></div></div>
<div class="ttc" id="aqep_8hpp_html_a397e2268692c869f154c918451a814a7"><div class="ttname"><a href="qep_8hpp.html#a397e2268692c869f154c918451a814a7">Q_STATE_DEF</a></div><div class="ttdeci">#define Q_STATE_DEF(subclass_, state_)</div><div class="ttdoc">Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00846">qep.hpp:846</a></div></div>
<div class="ttc" id="aqf_8hpp_html_a190067e72a37774fa0ecfc84dba14615"><div class="ttname"><a href="qf_8hpp.html#a190067e72a37774fa0ecfc84dba14615">Q_NEW_X</a></div><div class="ttdeci">#define Q_NEW_X(e_, evtT_, margin_, sig_,...)</div><div class="ttdoc">Non-asserting allocate a dynamic event (case when QP::QEvt is not a POD)</div><div class="ttdef"><b>Definition:</b> <a href="qf_8hpp_source.html#l01670">qf.hpp:1670</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01817">1817</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a9a12c5b2f250d8d874a2ec0ba72a0676" name="a9a12c5b2f250d8d874a2ec0ba72a0676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a12c5b2f250d8d874a2ec0ba72a0676">&#9670;&#160;</a></span>TICK_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TICK_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tickRate_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;tick_((tickRate_), (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro is the recommended way of invoking clock tick processing, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tickRate_</td><td>clock tick rate to be serviced through this call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sender_</td><td>pointer to the sender object. This parameter is actually only used when QS software tracing is enabled (macro <a class="el" href="config_8hpp.html#a668b5df6d955d0b1c77227192078689b" title="The preprocessor switch to activate the QS software tracing instrumentation in the code.">Q_SPY</a> is defined) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When QS software tracing is disabled, the macro calls QTimeEvt::tick_() without the <code>sender</code> parameter, so the overhead of passing this extra parameter is entirely avoided.</dd>
<dd>
The pointer to the sender object is not necessarily a pointer to an active object. In fact, when <a class="el" href="qf_8hpp.html#a9a12c5b2f250d8d874a2ec0ba72a0676" title="Invoke the system clock tick processing QTimeEvt::tick_()">TICK_X()</a> is called from an interrupt, you would create a unique object just to unambiguously identify the ISR as the sender of the time events.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QTimeEvt::tick_() </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01851">1851</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="acb95c078f4da69732d4bfee44e3c52e4" name="acb95c078f4da69732d4bfee44e3c52e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb95c078f4da69732d4bfee44e3c52e4">&#9670;&#160;</a></span>TICK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TICK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qf_8hpp.html#a9a12c5b2f250d8d874a2ec0ba72a0676">TICK_X</a>(0U, (sender_))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="qf_8hpp.html#a9a12c5b2f250d8d874a2ec0ba72a0676" title="Invoke the system clock tick processing QTimeEvt::tick_()">TICK_X()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01862">1862</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="adc8820f52d450bcfb7d1f830e6c8a8c2" name="adc8820f52d450bcfb7d1f830e6c8a8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8820f52d450bcfb7d1f830e6c8a8c2">&#9670;&#160;</a></span>QF_CRIT_EXIT_NOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_CRIT_EXIT_NOP</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(static_cast&lt;void&gt;(0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In some QF ports the critical section exit takes effect only on the next machine instruction. If this next instruction is another entry to a critical section, the critical section won't be really exited, but rather the two adjecent critical sections would be merged. The <a class="el" href="qf_8hpp.html#adc8820f52d450bcfb7d1f830e6c8a8c2" title="No-operation for exiting a critical section.">QF_CRIT_EXIT_NOP()</a> macro contains minimal code required to prevent such merging of critical sections in such merging of critical sections in QF ports, in which it can occur. </p>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01876">1876</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa5b03905caeba6d995816003374e3717" name="aa5b03905caeba6d995816003374e3717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b03905caeba6d995816003374e3717">&#9670;&#160;</a></span>QF_onContextSw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onContextSw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_active.html">QP::QActive</a> *&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_active.html">QP::QActive</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback function provides a mechanism to perform additional custom operations when one of the built-in kernels switches context from one thread to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev</td><td>pointer to the previous thread (active object) (prev==0 means that <code>prev</code> was the QK idle loop) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">next</td><td>pointer to the next thread (active object) (next==0) means that <code>next</code> is the QK idle loop) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><a class="el" href="qf_8hpp.html#aa5b03905caeba6d995816003374e3717" title="QF context switch callback used in built-in kernels.">QF_onContextSw()</a> is invoked with interrupts <b>disabled</b> and must also return with interrupts <b>disabled</b>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is enabled by defining the macro <a class="el" href="config_8hpp.html#a3e0c41a1acf5990304c36eecd99e930d" title="This macro enables calling the QK context-switch callback QF_onContextSw()">QF_ON_CONTEXT_SW</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> { <span class="comment">// use the &quot;C&quot; calling convention</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef QF_ON_CONTEXT_SW</span></div>
<div class="line"><span class="comment">// NOTE: the context-switch callback is called with interrupts DISABLED</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="qf_8hpp.html#aa5b03905caeba6d995816003374e3717">QF_onContextSw</a>(QActive *prev, QActive *next) {</div>
<div class="line">    <span class="keywordflow">if</span> (next != (QActive *)0) { <span class="comment">// next is not the QK idle loop?</span></div>
<div class="line">        _impure_ptr = next-&gt;thread; <span class="comment">// switch to next TLS</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If you use QS software tracing, use the _NOCRIT() begin/end</span></div>
<div class="line">    <a class="code hl_define" href="qs_8hpp.html#a98ae9bc427910662dc53ed1d15aaa044">QS_BEGIN_NOCRIT</a>(ON_CONTEXT_SW, 0U)</div>
<div class="line">        QS_OBJ(prev);</div>
<div class="line">        QS_OBJ(next);</div>
<div class="line">    <a class="code hl_define" href="qs_8hpp.html#a2d38d50c6d69094bbe3bee00de5140d0">QS_END_NOCRIT</a>()</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// QF_ON_CONTEXT_SW</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// extern &quot;C&quot;</span></div>
<div class="ttc" id="aqf_8hpp_html_aa5b03905caeba6d995816003374e3717"><div class="ttname"><a href="qf_8hpp.html#aa5b03905caeba6d995816003374e3717">QF_onContextSw</a></div><div class="ttdeci">void QF_onContextSw(QP::QActive *prev, QP::QActive *next)</div><div class="ttdoc">QF context switch callback used in built-in kernels.</div></div>
<div class="ttc" id="aqs_8hpp_html_a2d38d50c6d69094bbe3bee00de5140d0"><div class="ttname"><a href="qs_8hpp.html#a2d38d50c6d69094bbe3bee00de5140d0">QS_END_NOCRIT</a></div><div class="ttdeci">#define QS_END_NOCRIT()</div><div class="ttdoc">End an application-specific QS record WITHOUT exiting critical section.</div><div class="ttdef"><b>Definition:</b> <a href="qs_8hpp_source.html#l01020">qs.hpp:1020</a></div></div>
<div class="ttc" id="aqs_8hpp_html_a98ae9bc427910662dc53ed1d15aaa044"><div class="ttname"><a href="qs_8hpp.html#a98ae9bc427910662dc53ed1d15aaa044">QS_BEGIN_NOCRIT</a></div><div class="ttdeci">#define QS_BEGIN_NOCRIT(rec_, qs_id_)</div><div class="ttdoc">Begin an application-specific QS record WITHOUT entering critical section.</div><div class="ttdef"><b>Definition:</b> <a href="qs_8hpp_source.html#l01013">qs.hpp:1013</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ba9212edd50725fad9f78ab40930b956.html">include</a></li><li class="navelem"><a class="el" href="qf_8hpp.html">qf.hpp</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
