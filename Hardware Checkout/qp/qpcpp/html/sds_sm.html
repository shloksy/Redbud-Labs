<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: State Machines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C++
    &nbsp;<span id="projectnumber">7.2.1</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('sds_sm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">State Machines </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="sds.html">Design (SDS)</a></span> </p>
<div style="clear:both;"></div><p> The behavior of each active object in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework is specified by means of a <a href="https://www.state-machine.com/fsm/#HSM" class="extern" target="_blank">hierarchical state machine</a> (UML statechart), which is the most effective and elegant technique of describing event-driven behavior. The most important innovation of UML state machines over classical finite state machines (FSMs) is the hierarchical state nesting. The value of state nesting lies in avoiding repetitions, which are inevitable in the traditional "flat" FSM formalism and are the main reason for the "state-transition explosion" in FSMs. The semantics of state nesting allow substates to define only the differences of behavior from the superstates, thus promoting sharing and reusing behavior.</p>
<p>The Quantum Leaps Application Note <a href="https://www.state-machine.com/doc/AN_Crash_Course_in_UML_State_Machines.pdf" class="extern" target="_blank"><b>A Crash Course in UML State Machines</b></a> introduces the main state machine concepts backed up by examples.</p>
<dl class="section note"><dt>Note</dt><dd>The hallmark of the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a> Framework implementation of UML state machines is <b>traceability</b>, which is direct, precise, and unambiguous mapping of every state machine element to human-readable, portable code. Preserving the traceability from requirements through design to code is essential for mission-critical systems, such as medical devices or avionic systems.</dd></dl>
<p>This section describes how to implement <a href="https://www.state-machine.com/fsm/#HSM" class="extern">hierarchical state machines</a> with the <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C real-time embedded framework, which is quite a mechanical process consisting of just a few simple rules. (In fact, the process of coding state machines in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C has been automated by the QM model-based design and code-generating tool.)</p>
<p>To focus this discussion, this section uses the Calculator example, located in the directory <span class="img folder">qpcpp/examples/workstation/calc</span>. This example has been used in the <a href="https://www.state-machine.com/psicc2" class="extern">PSiCC2 book</a> (Section 4.6 "Summary of Steps for Implementing HSMs with QEP")</p>
<p>This section explains how to code the following (marked) elements of a hierarchical state machine:</p>
<div class="image">
<img src="sds_calc.png" alt=""/>
<div class="caption">
Fragment of the Calculator hierarchical state machine</div></div>
 <p><code>[1]</code> The top-most initial pseudo-state</p>
<p><code>[2]</code> A state (nested in the implicit <code>top</code> state)</p>
<p><code>[3]</code> An entry action to a state</p>
<p><code>[4]</code> An exit action from a state</p>
<p><code>[5]</code> An initial transition nested in a state</p>
<p><code>[6]</code> A regular state transition</p>
<p><code>[7]</code> A state (substate) nested in another state (superstate)</p>
<p><code>[8]</code> Even more deeply nested substate</p>
<p><code>[9]</code> A choice point with a guard</p>
<dl class="section note"><dt>Note</dt><dd>This section describes the QHsm state machine implementation strategy, suitable for <b>manual coding</b> of hierarchical state machines in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++. The alternative QMsm state machine implementation strategy, which <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ also supports, is not covered in this section, as the code needs to be generated automatically by the <a href="https://www.state-machine.com/products/qm/" class="extern" target="_blank">QM modeling tool</a>.</dd></dl>
<dl class="section user"><dt>Historical Notes</dt><dd>The previous implementation (from <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ version 3.x through 6.4.x) used state-handlers that were <code>static</code> members of the state machine class, which don't have the <code>this</code> pointer and therefore needed to use the specially supplied <b>"me-&gt; pointer"</b> to access the members of the state machine class. That previous "me-&gt; pointer" state machine implementation style is still supported in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ for backwards compatibility with the existing code, but it is <b>not</b> recommended for new designs.<br  />
 <br  />
 An even earlier <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ state machine implementation strategy, used in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ version 2.x and published in the first edition of the <a href="https://www.state-machine.com/psicc" class="extern">PSiCC book</a>, also implemented state handlers as regular <em>members</em> of the state machine class. However, this earlier implementation relied internally on pointers to <em>member</em> functions, which turned out to be a problematic in practice, because some embedded C++ compilers at the time didn't implement pointers to <em>member</em> functions efficiently. Therefore, the implementation published in the second edition of the <a href="https://www.state-machine.com/psicc2" class="extern">PSiCC2 book</a>, switched to <em>static</em> state-handler functions (without the <code>this</code> pointer), which allowed it to use internally the simple pointers to functions that are very efficient.<br  />
 <br  />
 This latest "no me-&gt; pointer" state machine implementation style in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ applies a hybrid approach. Internally, it represents states as simple and efficient pointers to "state-caller" functions. But these "state-caller" functions call "state-handlers" as regular members of the state machine class, which have the <code>this</code> pointer and therefore can access all members of the state machine class naturally (without the need for the "me-&gt; pointer").</dd></dl>
<h1><a class="anchor" id="sm_decl"></a>
State Machine Declaration</h1>
<p>Hierarchical state machines are represented in <a class="el" href="namespace_q_p.html" title="QP/C++ framework.">QP</a>&trade;/C++ as subclasses of the QHsm abstract base class, which is defined in the header file <span class="img folder"><a class="el" href="qep_8hpp.html" title="QEP/C++ platform-independent public interface.">qpcpp\include\qep.hpp</a></span>. Please note that abstract classes like <a class="el" href="class_q_p_1_1_q_msm.html" title="QM State Machine implementation strategy.">QP::QMsm</a>, <a class="el" href="class_q_p_1_1_q_active.html" title="QP::QActive active object class (based on the QP::QHsm-style implementation strategy)">QP::QActive</a> and <a class="el" href="class_q_p_1_1_q_m_active.html" title="QMActive active object (based on QP::QMsm implementation)">QP::QMActive</a> are also subclasses of <a class="el" href="class_q_p_1_1_q_hsm.html" title="Hierarchical State Machine abstract base class (ABC)">QP::QHsm</a>, so their subclasses also can have state machines.</p>
<div class="fragment"><div class="line">[1] <span class="keyword">class </span>Calc : <span class="keyword">public</span> <a class="code hl_class" href="class_q_p_1_1_q_hsm.html">QP::QHsm</a> {</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">[2]    <span class="keywordtype">double</span> m_operand1;</div>
<div class="line">       uint8_t m_operator;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">[3]     Calc() <span class="comment">// constructor</span></div>
<div class="line">[4]      : QHsm(&amp;initial) <span class="comment">// superclass&#39; constructor</span></div>
<div class="line">        {}</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">[5]     <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(initial);</div>
<div class="line">[6]     <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(on);</div>
<div class="line">        <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(ready);</div>
<div class="line">        <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(result);</div>
<div class="line">        <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(begin);</div>
<div class="line">        . . .</div>
<div class="ttc" id="aclass_q_p_1_1_q_hsm_html"><div class="ttname"><a href="class_q_p_1_1_q_hsm.html">QP::QHsm</a></div><div class="ttdoc">Hierarchical State Machine abstract base class (ABC)</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00293">qep.hpp:293</a></div></div>
<div class="ttc" id="aqep_8hpp_html_a966e403205453b082be4d73523d58cc4"><div class="ttname"><a href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a></div><div class="ttdeci">#define Q_STATE_DECL(state_)</div><div class="ttdoc">Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00839">qep.hpp:839</a></div></div>
</div><!-- fragment --><p><code>[1]</code> Class <code>Calc</code> (Calculator) derives from <a class="el" href="class_q_p_1_1_q_hsm.html" title="Hierarchical State Machine abstract base class (ABC)">QP::QHsm</a>, so it can have a state machine</p>
<p><code>[2]</code> The class can have data members (typically private), which will be accessible inside the state machine as the "extended-state variables".</p>
<p><a class="anchor" id="sm_ctor"></a><code>[3]</code> The class needs to provide a <b>constructor</b>, typically without any parameters.</p>
<p><code>[4]</code> The constructor must call the appropriate superclass' constructor. The superclass' constructor takes the top-most a pointer to the <code>initial</code> pseudo-state (see step [5]), which binds the state-machine to the class.</p>
<p><code>[5]</code> Each state machine must have exactly one initial pseudo-state, which by convention should be always called <b>initial</b>. The initial pseudo-state is declared with the macro <a class="el" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DECL(initial)</a>.</p>
<p><code>[6]</code> The same <a class="el" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DECL()</a> macro is also used to declare all other states in the state machine. </p><div style="clear:both;"></div><h2><a class="anchor" id="sm_state_decl"></a>
The Q_STATE_DECL() Macro</h2>
<p>The <a class="el" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DECL()</a> macro declares <b>two</b> functions for every state: the "state-handler" <b>regular member</b> function and the "state-caller" <b>static member</b> function. So, for example, the declaration of the "on" state <a class="el" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DECL(on)</a> expands to the following two declarations within the <code>Calc</code> class:</p>
<div class="fragment"><div class="line">[1] <a class="code hl_typedef" href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a> on_h(<a class="code hl_class" href="class_q_p_1_1_q_evt.html">QP::QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e); <span class="comment">// &quot;state-handler&quot;</span></div>
<div class="line">[2] <span class="keyword">static</span> <a class="code hl_typedef" href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a> on(<span class="keywordtype">void</span> * <span class="keyword">const</span> me, <a class="code hl_class" href="class_q_p_1_1_q_evt.html">QP::QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e); <span class="comment">// &quot;state-caller&quot;</span></div>
<div class="ttc" id="aclass_q_p_1_1_q_evt_html"><div class="ttname"><a href="class_q_p_1_1_q_evt.html">QP::QEvt</a></div><div class="ttdoc">Event class.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00163">qep.hpp:163</a></div></div>
<div class="ttc" id="anamespace_q_p_html_a12b7ba71c9618c6aa0e435ab8607f81f"><div class="ttname"><a href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a></div><div class="ttdeci">std::uint_fast8_t QState</div><div class="ttdoc">Type returned from state-handler functions.</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00209">qep.hpp:209</a></div></div>
</div><!-- fragment --><p>The two functions have each a different purpose.</p>
<p><code>[1]</code> The "state-handler" <code>on_h()</code> is a <b>regular member</b> function used to implement the state behavior. As a regular class member, it has convenient, direct access to the state machine class attributes. The "state-handler" is called by the "state-caller".</p>
<p><code>[2]</code> The "state-caller" <code>on()</code> is a <b>static member</b> function that has a simple job to call the state-handler member function on the specified instance of the class. Internally, the QEP event processor uses "state-callers" as unique "handles" for the states. Specifically, the QEP event processor uses the simple <b>function pointers</b> to these <code>state-callers</code>, which are simple objects (e.g. 32-bit addresses in ARM Cortex-M CPUs), because they don't use the <code>this</code> calling convention. These simple function pointers can be stored very efficiently inside the state machine objects and can be compared quickly inside the QEP algorithm that implements the UML semantics of hierarchical state machines.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sds_sm.html#sm_call">State-Handler Call Overhead</a></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Because the state-handler functions are regular members of the state machine class, they can be <code>virtual</code>, which allows them to be overridden in the subclasses of a given state machine class. Such <b>inheritance of entire sate machines</b> is an advanced concept, which should be used only in very special circumstances and with great caution. To declare a <code>virtual</code> state-handler, you simply prepend <code>virtual</code> in front of the <a class="el" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DECL()</a> macro, as in the following examples: <div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(on);</div>
<div class="line"><span class="keyword">virtual</span> <a class="code hl_define" href="qep_8hpp.html#a966e403205453b082be4d73523d58cc4">Q_STATE_DECL</a>(ready);</div>
<div class="line">. . .</div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="sm_def"></a>
State Machine Definition</h1>
<p>The definition of the state machine class is the actual code for your state machine. You need to define (i.e., write the code for) all "state-handler" member functions you declared in the <a class="el" href="sds_sm.html#sm_decl">state machine class declaration</a>. You don't need to explicitly define the "state-caller" static functions, because they are synthesized implicitly in the macro <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF()</a>).</p>
<p>One important aspect to realize about coding "state-handler" functions is that they are always called from the QEP event processor. The purpose of the "state-handlers" is to perform <em>your</em> specific actions and then to <em>tell</em> the event processor what needs to be done with the state machine. For example, if your "state-handler" performs a state transition, it executes some actions and then it calls the special <a class="el" href="class_q_p_1_1_q_hsm.html#a52aaf90f54f409e1c1734c0fc4d05188">tran(&lt;target&gt;)</a> function, where it specifies the <code>&lt;target&gt;</code> state of this state transition. The state-handler then <b>returns</b> the status from the <code>tran()</code> function, and through this return value it informs the QEP event processor what needs to be done with the state machine. Based on this information, the event-processor might decide to call this or other state-handler functions to process the same current event. The following code examples should make all this clearer.</p>
<h2><a class="anchor" id="sm_state_def"></a>
The Q_STATE_DEF() Macro</h2>
<p>Every state that has been declared with the <a class="el" href="sds_sm.html#sm_decl">Q_STATE_DECL()</a> macro in the state machine class needs to be defined with the <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF()</a> macro. For example, the state "ready" in the Calculator state machines, the <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF(Calc, ready)</a> macro expands into the following code:</p>
<div class="fragment"><div class="line">[1] <a class="code hl_typedef" href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a> Calc::ready(<span class="keywordtype">void</span> * <span class="keyword">const</span> me, <a class="code hl_class" href="class_q_p_1_1_q_evt.html">QP::QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Calc *<span class="keyword">&gt;</span>(me)-&gt;ready_h(e);</div>
<div class="line">    }</div>
<div class="line">[2] <a class="code hl_typedef" href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a> Calc::ready_h(<a class="code hl_class" href="class_q_p_1_1_q_evt.html">QP::QEvt</a> <span class="keyword">const</span> * <span class="keyword">const</span> e)</div>
</div><!-- fragment --><dl class="tag">
<dt>1</dt>
<dd>The static <code>Calc::ready()</code> state-caller function is fully defined to call the "state-handler" function on the provided <code>me</code> pointer, which is explicitly cast to the class instance.  </dd>
<dt>2</dt>
<dd>The signature of the <code>Calc::ready_h()</code> "state-handler" member function is provided, which needs to be followed by the body (<code>{...}</code>) of the "state-handler" member function.  </dd>
</dl>
<div style="clear:both;"></div><h2><a class="anchor" id="sm_def_init"></a>
Top-Most Initial Pseudostate</h2>
<p>Every state machine must have exactly one top-most initial pseudo-state, which is assumed when the state machine is instantiated in the <a class="el" href="sds_sm.html#sm_ctor">constructor</a> of the state machine class. By convention, the initial pseudo-state should be always called <b>initial</b>.</p>
<p>This top-most initial pseudo-state has one transition, which points to the state that will become active after the state machine is initialized (through the QHsm::init() function). The following code the definition of the <code>initial</code> pseudo-state for the <code>Calc</code> class:</p>
<div class="fragment"><div class="line">[1] <a class="code hl_define" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7">Q_STATE_DEF</a>(Calc, initial) {</div>
<div class="line">[2]      . . . <span class="comment">// initialize the members of the state machine class</span></div>
<div class="line">[3]      (void)e; <span class="comment">// unused parameter</span></div>
<div class="line">[4]      <span class="keywordflow">return</span> tran(&amp;on);</div>
<div class="line">    }</div>
<div class="ttc" id="aqep_8hpp_html_a397e2268692c869f154c918451a814a7"><div class="ttname"><a href="qep_8hpp.html#a397e2268692c869f154c918451a814a7">Q_STATE_DEF</a></div><div class="ttdeci">#define Q_STATE_DEF(subclass_, state_)</div><div class="ttdoc">Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00846">qep.hpp:846</a></div></div>
</div><!-- fragment --><p><code>[1]</code> The initial pseudo-state is defined by means of the macro <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF()</a>, which takes two parameters: the class name and the state name (<code>initial</code> in this case).</p>
<p><code>[2]</code> The function body following the macro <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF()</a> provides the definition of the "state-handler" member function, so it can access all class members via the implicit <code>this</code> pointer.</p>
<p><code>[3]</code> The initial pseudo-state receives the "initialization event" <code>e</code>, which is often not used. If the event is not used, this line of code avoids the compiler warning about unused parameter.</p>
<p><code>[4]</code> The top-most initial transition from the initial pseudo-state is coded with the function <a class="el" href="class_q_p_1_1_q_hsm.html#a52aaf90f54f409e1c1734c0fc4d05188">tran()</a>. The single parameter to the <code>tran()</code> function is the pointer to the target state of the transition. The top-most initial pseudo-state must return the value from the <code>tran()</code> function.</p>
<h2><a class="anchor" id="sm_def_state"></a>
State-Handler Member Functions</h2>
<p>Every regular state (including states nested in other states) is also coded with the <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF()</a> macro. The function body, following the macro, consists of the <code>switch</code> statement that discriminates based on the event signal (<code>e-&gt;sig</code>). The following code shows the complete definition of the Calculator "on" state. The explanation section below the code clarifies the main points.</p>
<div class="fragment"><div class="line">[1] <a class="code hl_define" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7">Q_STATE_DEF</a>(Calc, ready) {</div>
<div class="line">[2]     <a class="code hl_typedef" href="namespace_q_p.html#a12b7ba71c9618c6aa0e435ab8607f81f">QP::QState</a> status_;</div>
<div class="line">[3]     <span class="keywordflow">switch</span> (e-&gt;<a class="code hl_variable" href="class_q_p_1_1_q_evt.html#a20b1ceebb91aea39fcbc633aeae6cd3f">sig</a>) {</div>
<div class="line">[4]         <span class="keywordflow">case</span> Q_ENTRY_SIG: {</div>
<div class="line">[5]             BSP_message(<span class="stringliteral">&quot;ready-ENTRY;&quot;</span>);</div>
<div class="line">[6]             status_ = Q_RET_HANDLED;</div>
<div class="line">[7]             <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">[8]         <span class="keywordflow">case</span> Q_EXIT_SIG: {</div>
<div class="line">                BSP_message(<span class="stringliteral">&quot;ready-EXIT;&quot;</span>);</div>
<div class="line">[9]             status_ = Q_RET_HANDLED;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">[10]        <span class="keywordflow">case</span> Q_INIT_SIG: {</div>
<div class="line">                BSP_message(<span class="stringliteral">&quot;ready-INIT;&quot;</span>);</div>
<div class="line">[11]            status_ = tran(&amp;begin);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">case</span> DIGIT_0_SIG: {</div>
<div class="line">                BSP_clear();</div>
<div class="line">                status_ = tran(&amp;zero1);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">[12]        <span class="keywordflow">case</span> DIGIT_1_9_SIG: {</div>
<div class="line">                BSP_clear();</div>
<div class="line">[13]            BSP_insert(<a class="code hl_define" href="qep_8hpp.html#a383d313ef4661e5fd6dcd98014c270ea">Q_EVT_CAST</a>(CalcEvt)-&gt;key_code);</div>
<div class="line">[14]            status_ = tran(&amp;int1);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">case</span> POINT_SIG: {</div>
<div class="line">                BSP_clear();</div>
<div class="line">                BSP_insert((<span class="keywordtype">int</span>)<span class="charliteral">&#39;0&#39;</span>);</div>
<div class="line">                BSP_insert((<span class="keywordtype">int</span>)<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">                status_ = tran(&amp;frac1);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">case</span> OPER_SIG: {</div>
<div class="line">[15]            m_operand1 = BSP_get_value();</div>
<div class="line">[16]            m_operator = <a class="code hl_define" href="qep_8hpp.html#a383d313ef4661e5fd6dcd98014c270ea">Q_EVT_CAST</a>(CalcEvt)-&gt;key_code;</div>
<div class="line">                status_ = tran(&amp;opEntered);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">case</span> CE_SIG: {</div>
<div class="line">                BSP_clear();</div>
<div class="line">                status_ = tran(&amp;ready);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">[17]        <span class="keywordflow">default</span>: {</div>
<div class="line">[18]            status_ = super(&amp;on);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">[19]    <span class="keywordflow">return</span> status_;</div>
<div class="line">    }</div>
<div class="ttc" id="aclass_q_p_1_1_q_evt_html_a20b1ceebb91aea39fcbc633aeae6cd3f"><div class="ttname"><a href="class_q_p_1_1_q_evt.html#a20b1ceebb91aea39fcbc633aeae6cd3f">QP::QEvt::sig</a></div><div class="ttdeci">QSignal sig</div><div class="ttdoc">signal of the event instance RQP002</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00168">qep.hpp:168</a></div></div>
<div class="ttc" id="aqep_8hpp_html_a383d313ef4661e5fd6dcd98014c270ea"><div class="ttname"><a href="qep_8hpp.html#a383d313ef4661e5fd6dcd98014c270ea">Q_EVT_CAST</a></div><div class="ttdeci">#define Q_EVT_CAST(subclass_)</div><div class="ttdoc">Perform downcast of an event onto a subclass of QEvt class_</div><div class="ttdef"><b>Definition:</b> <a href="qep_8hpp_source.html#l00867">qep.hpp:867</a></div></div>
</div><!-- fragment --><p><code>[1]</code> The state is defined by means of the macro <a class="el" href="qep_8hpp.html#a397e2268692c869f154c918451a814a7" title="Macro to generate a declaration of a state-handler, state-caller and a state-object for a given state...">Q_STATE_DEF()</a>, which takes two parameters: the class name and the state name (<code>on</code> in this case).</p>
<p><code>[2]</code> The automatic variable <code>status_</code> will hold the status of what will happen in the state-handler. This status will be eventually returned from the state-handler to the QEP event processor.</p>
<p><code>[3]</code> Generally, every state handler is structured as a single switch that discriminates based on the signal of the <b>current event</b> <code>e-&gt;sig</code>, which is passed to the state-handler as parameter.</p>
<p><code>[4]</code> The special, reserved event signal <a class="el" href="class_q_p_1_1_q_hsm.html#a43381689e2b3f60ba137b623d327fc53ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a> is generated by the QEP event processor to let the state-handler process an <b>entry action</b> to the state.<br  />
 </p><dl class="section remark"><dt>Remarks</dt><dd>&#160;By convention, all event signals end with the <code>_SIG</code> suffix. The <code>_SIG</code> suffix is omitted in the QM state machine diagrams.</dd></dl>
<p><code>[5]</code> You place your own code, which might contain references to the members of the state machine class (via the implicit <code>this</code> pointer)</p>
<p><code>[6]</code> After your <em>entry action</em> code, you inform the QEP event processor that the state entry has been handled by setting <code>status_</code> to <a class="el" href="class_q_p_1_1_q_hsm.html#a955ca1a118a0248c1f1f8d5d7ca1f1aea325b2795ef0c708f6539136a65367570">Q_RET_HANDLED</a>.</p>
<p><code>[7]</code> Finally, you close each <code>case</code> with the <code>break</code> statement.</p>
<p><code>[8]</code> The special, reserved event signal <a class="el" href="class_q_p_1_1_q_hsm.html#a43381689e2b3f60ba137b623d327fc53ab54538c21a62926a2f1d63d8fd45bf5c">Q_EXIT_SIG</a> is generated by the QEP event processor to let the state-handler process an <b>exit action</b> from the state.</p>
<p><code>[9]</code> Again, after your <em>exit action</em> code, you inform the QEP event processor that the state exit has been handled by setting <code>status_</code> to <a class="el" href="class_q_p_1_1_q_hsm.html#a955ca1a118a0248c1f1f8d5d7ca1f1aea325b2795ef0c708f6539136a65367570">Q_RET_HANDLED</a>.</p>
<p><code>[10]</code> The special, reserved event signal <a class="el" href="class_q_p_1_1_q_hsm.html#a43381689e2b3f60ba137b623d327fc53a28691a94425fb031be4044e817e21a60">Q_INIT_SIG</a> is generated by the QEP event processor to let the state-handler process an <b>initial transition</b> nested in the state.</p>
<p><code>[11]</code> After your <em>initial action</em> code, you inform the QEP event processor to complete the initial transition and to go to the specified target state indicated as the parameter of the <a class="el" href="class_q_p_1_1_q_hsm.html#a52aaf90f54f409e1c1734c0fc4d05188">tran()</a> function. You set <code>status_</code> to the value returned from <code>tran()</code>.</p>
<p><code>[12]</code> A user-defined event, like <code>DIGIT_1_9_SIG</code> is handled in its own <code>case</code> statement.</p>
<p><code>[13]</code> The state-handler code has access to the <b>current event <code>e</code></b>. The macro <a class="el" href="qep_8hpp.html#a383d313ef4661e5fd6dcd98014c270ea" title="Perform downcast of an event onto a subclass of QEvt class_">Q_EVT_CAST()</a> encapsulates <b>downcasting</b> the event pointer <code>e</code> to the specific event type (<code>CalcEvt</code> in this case).</p>
<p><code>[14]</code> The <code>DIGIT_1_9_SIG</code> event triggers a state transition to state "int1", which you code with the <a class="el" href="class_q_p_1_1_q_hsm.html#a52aaf90f54f409e1c1734c0fc4d05188">tran(&amp;int1)</a> function.</p>
<p><code>[15-16]</code> &#160;The state-handler function has direct access to the data members of the <code>Calc</code> class.<br  />
 </p><dl class="section remark"><dt>Remarks</dt><dd>&#160;The previous implementation would require the use of "me-&gt;" pointer to access the data members.</dd></dl>
<p><code>[17]</code> The <code>default</code> case handles the situation when this state does not prescribe how to handle the given event. This is where you define the <b>superstate</b> of the given state.</p>
<p><code>[18]</code> The <b>superstate</b> of the given state is specified by calling the <a class="el" href="class_q_p_1_1_q_hsm.html#ad1d5908821a9d7e37bc6513961aee729">super()</a> function.<br  />
 </p><dl class="section remark"><dt>Remarks</dt><dd>&#160;A state that does not explicitly nest in any state, such as the "on" state in the Calculator, calls <b>super(&amp;top)</b></dd></dl>
<p><code>[19]</code> The state-handler ends by returning the status to the QEP event processor.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>switch</code> statement code and the single <code>return</code> from the state-handler function is compliant with the AUTOSAR-C++:2014 standard.</dd></dl>
<h1><a class="anchor" id="sm_call"></a>
State-Handler Call Overhead</h1>
<p>For embedded system applications, it is always interesting to know the overhead of the implementation used. It turns out that the chosen "state-caller"/"state-handler" implementation is very efficient. The following dis-assembly listing shows the code generated for invocation of a state-handler from the QEP code. The compiler used is IAR C/C++ EWARM 8.32 with Cortex-M target CPU and Medium level of optimization.</p>
<div class="fragment"><div class="line">        r = (*s)(this, e); // invoke state handler s</div>
<div class="line">[1] MOV       R1, R7       // place `e` pointer in R1</div>
<div class="line">[2] MOV       R0, R6       // place `this` pointer in R0</div>
<div class="line">[3] BLX       R4           // branch to the state-caller</div>
<div class="line"> </div>
<div class="line">        state-caller:</div>
<div class="line">[4] B.W       MyHsm::state_h() ; branch to state-handler member</div>
</div><!-- fragment --><p>The machine code instructions [1-3] are the minimum code to call a function with two parameters via a function pointer (in R4). The single branch instruction [4] represents the only overhead of using the "state-caller" indirection layer. This instruction takes about 4 CPU clock cycles, which is minuscule and typically much better than using a pointer to a C++ <em>member</em> function.</p>
<p><span class="prev_button"><a class="el" href="sds.html">Design (SDS)</a></span>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="sds.html">Design (SDS)</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
