<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C++: QP::QF Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C++
    &nbsp;<span id="projectnumber">7.2.1</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespace_q_p_1_1_q_f.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">QP::QF Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>hierarchical event processor and active object framework
</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr class="memdesc:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> initialization.  <br /></td></tr>
<tr class="separator:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c528baf37154d347366083f0f816846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a8c528baf37154d347366083f0f816846">stop</a> ()</td></tr>
<tr class="memdesc:a8c528baf37154d347366083f0f816846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> application and return control to the OS/Kernel.  <br /></td></tr>
<tr class="separator:a8c528baf37154d347366083f0f816846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938249408b2c41a001b202cf9ab3b6fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a938249408b2c41a001b202cf9ab3b6fd">run</a> ()</td></tr>
<tr class="memdesc:a938249408b2c41a001b202cf9ab3b6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> to run the application.  <br /></td></tr>
<tr class="separator:a938249408b2c41a001b202cf9ab3b6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe6b9a07bf7ed9a924b042c3bcc8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#af8fe6b9a07bf7ed9a924b042c3bcc8a5">onStartup</a> ()</td></tr>
<tr class="memdesc:af8fe6b9a07bf7ed9a924b042c3bcc8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> callback (defined in applications/ports)  <br /></td></tr>
<tr class="separator:af8fe6b9a07bf7ed9a924b042c3bcc8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328327af4c61c92fe5f6d9786d8b90c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a328327af4c61c92fe5f6d9786d8b90c1">onCleanup</a> ()</td></tr>
<tr class="memdesc:a328327af4c61c92fe5f6d9786d8b90c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> callback (defined in applications/ports)  <br /></td></tr>
<tr class="separator:a328327af4c61c92fe5f6d9786d8b90c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2661f3a8d818b3e3eebaabda9b4ced5a"><td class="memItemLeft" align="right" valign="top">std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a2661f3a8d818b3e3eebaabda9b4ced5a">getQueueMin</a> (std::uint_fast8_t const prio) noexcept</td></tr>
<tr class="memdesc:a2661f3a8d818b3e3eebaabda9b4ced5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the minimum of free entries of the given event queue of an active object (indicated by priority <code>prio</code>)  <br /></td></tr>
<tr class="separator:a2661f3a8d818b3e3eebaabda9b4ced5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26009462ff1baafe3c177c8118f874d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a26009462ff1baafe3c177c8118f874d2">psInit</a> (<a class="el" href="namespace_q_p.html#abf70f82ef06023008c568e80e1e85ad9">QSubscrList</a> *const subscrSto, <a class="el" href="qep_8hpp.html#a17507c4fc030f571427f3a79e83d4277">enum_t</a> const maxSignal) noexcept</td></tr>
<tr class="memdesc:a26009462ff1baafe3c177c8118f874d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <br /></td></tr>
<tr class="separator:a26009462ff1baafe3c177c8118f874d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b38af4b7b4aecc95b1a36d141e873a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#af3b38af4b7b4aecc95b1a36d141e873a">publish_</a> (<a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const e, void const *const sender, std::uint_fast8_t const qs_id) noexcept</td></tr>
<tr class="memdesc:af3b38af4b7b4aecc95b1a36d141e873a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to all subscribers of a given signal <code>e-&gt;sig</code>  <br /></td></tr>
<tr class="separator:af3b38af4b7b4aecc95b1a36d141e873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961322593bf7e0d7821e1bd7b4f5f6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a961322593bf7e0d7821e1bd7b4f5f6b0">tick_</a> (std::uint_fast8_t const tickRate, void const *const sender) noexcept</td></tr>
<tr class="memdesc:a961322593bf7e0d7821e1bd7b4f5f6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <br /></td></tr>
<tr class="separator:a961322593bf7e0d7821e1bd7b4f5f6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81f33393cd2fe6390bd451dad555545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#ab81f33393cd2fe6390bd451dad555545">poolInit</a> (void *const poolSto, std::uint_fast32_t const poolSize, std::uint_fast16_t const evtSize) noexcept</td></tr>
<tr class="memdesc:ab81f33393cd2fe6390bd451dad555545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <br /></td></tr>
<tr class="separator:ab81f33393cd2fe6390bd451dad555545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f78ae7178a02a2bb60889d413c6df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a96f78ae7178a02a2bb60889d413c6df4">newX_</a> (std::uint_fast16_t const evtSize, std::uint_fast16_t const margin, <a class="el" href="qep_8hpp.html#a17507c4fc030f571427f3a79e83d4277">enum_t</a> const sig) noexcept</td></tr>
<tr class="memdesc:a96f78ae7178a02a2bb60889d413c6df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> implementation of creating new dynamic mutable event.  <br /></td></tr>
<tr class="separator:a96f78ae7178a02a2bb60889d413c6df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f70fa40bdb5a9ed3524c5309be685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a7d5f70fa40bdb5a9ed3524c5309be685">gc</a> (<a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const e) noexcept</td></tr>
<tr class="memdesc:a7d5f70fa40bdb5a9ed3524c5309be685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <br /></td></tr>
<tr class="separator:a7d5f70fa40bdb5a9ed3524c5309be685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2404cde36d1b1209a1cf894fcdd79f"><td class="memItemLeft" align="right" valign="top">std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a8b2404cde36d1b1209a1cf894fcdd79f">poolGetMaxBlockSize</a> () noexcept</td></tr>
<tr class="memdesc:a8b2404cde36d1b1209a1cf894fcdd79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the block size of any registered event pools.  <br /></td></tr>
<tr class="separator:a8b2404cde36d1b1209a1cf894fcdd79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc01bf7f20f6517953de5ef28af442fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#acc01bf7f20f6517953de5ef28af442fb">newRef_</a> (<a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const e, <a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const evtRef) noexcept</td></tr>
<tr class="memdesc:acc01bf7f20f6517953de5ef28af442fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> implementation of creating new event reference.  <br /></td></tr>
<tr class="separator:acc01bf7f20f6517953de5ef28af442fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a52e38f626220d0568f56446bb09c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a89a52e38f626220d0568f56446bb09c7">deleteRef_</a> (<a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const evtRef) noexcept</td></tr>
<tr class="memdesc:a89a52e38f626220d0568f56446bb09c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> implementation of deleting event reference.  <br /></td></tr>
<tr class="separator:a89a52e38f626220d0568f56446bb09c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a7c81ff3770d311e78876574dfd0f8"><td class="memItemLeft" align="right" valign="top">std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a10a7c81ff3770d311e78876574dfd0f8">getPoolMin</a> (std::uint_fast8_t const poolId) noexcept</td></tr>
<tr class="memdesc:a10a7c81ff3770d311e78876574dfd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the minimum of free entries of the given event pool.  <br /></td></tr>
<tr class="separator:a10a7c81ff3770d311e78876574dfd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996109d745da0df30e1ac64d2975ee01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a996109d745da0df30e1ac64d2975ee01">bzero</a> (void *const start, std::uint_fast16_t const len) noexcept</td></tr>
<tr class="memdesc:a996109d745da0df30e1ac64d2975ee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a specified region of memory to zero.  <br /></td></tr>
<tr class="separator:a996109d745da0df30e1ac64d2975ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a411345fbc8d3502ee62bd80cc607376b"><td class="memItemLeft" align="right" valign="top">std::uint_fast8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a411345fbc8d3502ee62bd80cc607376b">intLock_</a></td></tr>
<tr class="memdesc:a411345fbc8d3502ee62bd80cc607376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt lock up-down counter (used in some <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> ports)  <br /></td></tr>
<tr class="separator:a411345fbc8d3502ee62bd80cc607376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03f48742df08a06b203ef53de9409da"><td class="memItemLeft" align="right" valign="top">std::uint_fast8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#ac03f48742df08a06b203ef53de9409da">intNest_</a></td></tr>
<tr class="memdesc:ac03f48742df08a06b203ef53de9409da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt nesting up-down counter (used in some <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> ports)  <br /></td></tr>
<tr class="separator:ac03f48742df08a06b203ef53de9409da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75157d4683e3ffe18bbd169033a7c034"><td class="memItemLeft" align="right" valign="top">constexpr std::uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034">NO_MARGIN</a> {0xFFFFU}</td></tr>
<tr class="memdesc:a75157d4683e3ffe18bbd169033a7c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value of margin that causes asserting failure in case event allocation or event posting fails.  <br /></td></tr>
<tr class="separator:a75157d4683e3ffe18bbd169033a7c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fff89f1c6ead93de377d5d17ae675fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_q_p_1_1_q_p_set.html">QPSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a2fff89f1c6ead93de377d5d17ae675fc">readySet_</a></td></tr>
<tr class="memdesc:a2fff89f1c6ead93de377d5d17ae675fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Ready-set" of all threads used in the built-in kernels  <br /></td></tr>
<tr class="separator:a2fff89f1c6ead93de377d5d17ae675fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c858e1104e86dd9b4b2c0630f2bf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qk_8hpp.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#af8c858e1104e86dd9b4b2c0630f2bf4d">ePool_</a> [<a class="el" href="qf__port_8hpp.html#ae2e7347d1d59f5a0410bbf92e9f141f3">QF_MAX_EPOOL</a>]</td></tr>
<tr class="memdesc:af8c858e1104e86dd9b4b2c0630f2bf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">event pools managed by <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a>  <br /></td></tr>
<tr class="separator:af8c858e1104e86dd9b4b2c0630f2bf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fe7d509e4fdffeb1bb258eb99202bd"><td class="memItemLeft" align="right" valign="top">std::uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_q_p_1_1_q_f.html#a21fe7d509e4fdffeb1bb258eb99202bd">maxPool_</a></td></tr>
<tr class="memdesc:a21fe7d509e4fdffeb1bb258eb99202bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of initialized event pools  <br /></td></tr>
<tr class="separator:a21fe7d509e4fdffeb1bb258eb99202bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a02fd73d861ef2e4aabb38c0c9ff82947" name="a02fd73d861ef2e4aabb38c0c9ff82947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd73d861ef2e4aabb38c0c9ff82947">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> and must be called exactly once before any other <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> function. Typcially, <a class="el" href="namespace_q_p_1_1_q_f.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="QF initialization.">QP::QF::init()</a> is called from main() even before initializing the Board Support Package (BSP).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_q_p_1_1_q_f.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="QF initialization.">QP::QF::init()</a> clears the internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> variables, so that the framework can start correctly even if the startup code fails to clear the uninitialized data (as is required by the C Standard). </dd></dl>
<p>Clear the internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> variables, so that the framework can start correctly even if the startup code fails to clear the uninitialized data (as is required by the C++ Standard).</p>
<p>Clear the internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> variables, so that the framework can start correctly even if the startup code fails to clear the uninitialized data (as is required by the C++ Standard).</p>

<p class="definition">Definition at line <a class="el" href="qk_8cpp_source.html#l00151">151</a> of file <a class="el" href="qk_8cpp_source.html">qk.cpp</a>.</p>

</div>
</div>
<a id="a8c528baf37154d347366083f0f816846" name="a8c528baf37154d347366083f0f816846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c528baf37154d347366083f0f816846">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function stops the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> application. After calling this function, <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this function is for terminating the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</p>
<dl class="section attention"><dt>Attention</dt><dd>After calling <a class="el" href="namespace_q_p_1_1_q_f.html#a8c528baf37154d347366083f0f816846" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> the application must terminate and cannot continue. In particular, <a class="el" href="namespace_q_p_1_1_q_f.html#a8c528baf37154d347366083f0f816846" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> is <b>not</b> intended to be followed by a call to <a class="el" href="namespace_q_p_1_1_q_f.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="QF initialization.">QF::init()</a> to "resurrect" the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_q_p_1_1_q_f.html#a328327af4c61c92fe5f6d9786d8b90c1" title="Cleanup QF callback (defined in applications/ports)">QP::QF::onCleanup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8cpp_source.html#l00178">178</a> of file <a class="el" href="qk_8cpp_source.html">qk.cpp</a>.</p>

</div>
</div>
<a id="a938249408b2c41a001b202cf9ab3b6fd" name="a938249408b2c41a001b202cf9ab3b6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938249408b2c41a001b202cf9ab3b6fd">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespace_q_p_1_1_q_f.html#a938249408b2c41a001b202cf9ab3b6fd" title="Transfers control to QF to run the application.">QF::run()</a> is typically called from your startup code after you initialize the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> and start at least one active object with <a class="el" href="class_q_p_1_1_q_active.html#a72321c5b6f9f216ab9fc35d77a2c964b" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>In <a class="el" href="namespace_q_p_1_1_q_k.html" title="preemptive, non-blocking kernel">QK</a>, the <a class="el" href="namespace_q_p_1_1_q_f.html#a938249408b2c41a001b202cf9ab3b6fd" title="Transfers control to QF to run the application.">QP::QF::run()</a> function does not return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8cpp_source.html#l00184">184</a> of file <a class="el" href="qk_8cpp_source.html">qk.cpp</a>.</p>

</div>
</div>
<a id="af8fe6b9a07bf7ed9a924b042c3bcc8a5" name="af8fe6b9a07bf7ed9a924b042c3bcc8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fe6b9a07bf7ed9a924b042c3bcc8a5">&#9670;&#160;</a></span>onStartup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onStartup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The purpose of the <a class="el" href="namespace_q_p_1_1_q_f.html#af8fe6b9a07bf7ed9a924b042c3bcc8a5" title="Startup QF callback (defined in applications/ports)">QF::onStartup()</a> callback is to configure and enable hardware interrupts. The callback is invoked from <a class="el" href="namespace_q_p_1_1_q_f.html#a938249408b2c41a001b202cf9ab3b6fd" title="Transfers control to QF to run the application.">QF::run()</a>, right before starting the underlying real-time kernel. By that time, the application is considered ready to receive and service interrupts.</p>
<p>This function is application-specific and is not implemented in <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a>, but rather in the Board Support Package (BSP) for the given application. </p>

</div>
</div>
<a id="a328327af4c61c92fe5f6d9786d8b90c1" name="a328327af4c61c92fe5f6d9786d8b90c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328327af4c61c92fe5f6d9786d8b90c1">&#9670;&#160;</a></span>onCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onCleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2661f3a8d818b3e3eebaabda9b4ced5a" name="a2661f3a8d818b3e3eebaabda9b4ced5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2661f3a8d818b3e3eebaabda9b4ced5a">&#9670;&#160;</a></span>getQueueMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast16_t getQueueMin </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t const&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_q_p_1_1_q_f.html#a2661f3a8d818b3e3eebaabda9b4ced5a" title="This function returns the minimum of free entries of the given event queue of an active object (indic...">QF::getQueueMin()</a> is available only when the native <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> event queue implementation is used. Requesting the queue minimum of an unused priority level raises an assertion in the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a>. (A priority level becomes used in <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> after the call to <a class="el" href="class_q_p_1_1_q_active.html#a6984a103d4023a4f23a98c922be32c30" title="Register this active object to be managed by the framework.">QActive::register_()</a>.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Priority of the active object, whose queue is queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__actq_8cpp_source.html#l00328">328</a> of file <a class="el" href="qf__actq_8cpp_source.html">qf_actq.cpp</a>.</p>

</div>
</div>
<a id="a26009462ff1baafe3c177c8118f874d2" name="a26009462ff1baafe3c177c8118f874d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26009462ff1baafe3c177c8118f874d2">&#9670;&#160;</a></span>psInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void psInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_q_p.html#abf70f82ef06023008c568e80e1e85ad9">QSubscrList</a> *const&#160;</td>
          <td class="paramname"><em>subscrSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8hpp.html#a17507c4fc030f571427f3a79e83d4277">enum_t</a> const&#160;</td>
          <td class="paramname"><em>maxSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>superseded by <a class="el" href="class_q_p_1_1_q_active.html#a26009462ff1baafe3c177c8118f874d2" title="Publish-subscribe initialization.">QActive::psInit()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01348">1348</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="af3b38af4b7b4aecc95b1a36d141e873a" name="af3b38af4b7b4aecc95b1a36d141e873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b38af4b7b4aecc95b1a36d141e873a">&#9670;&#160;</a></span>publish_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void publish_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint_fast8_t const&#160;</td>
          <td class="paramname"><em>qs_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>superseded by <a class="el" href="class_q_p_1_1_q_active.html#af3b38af4b7b4aecc95b1a36d141e873a" title="Publish event to all subscribers of a given signal e-&gt;sig">QActive::publish_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01360">1360</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a961322593bf7e0d7821e1bd7b4f5f6b0" name="a961322593bf7e0d7821e1bd7b4f5f6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961322593bf7e0d7821e1bd7b4f5f6b0">&#9670;&#160;</a></span>tick_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tick_ </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t const&#160;</td>
          <td class="paramname"><em>tickRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>superseded by <a class="el" href="class_q_p_1_1_q_time_evt.html#a961322593bf7e0d7821e1bd7b4f5f6b0" title="Processes all armed time events at every clock tick.">QTimeEvt::tick_()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01373">1373</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="ab81f33393cd2fe6390bd451dad555545" name="ab81f33393cd2fe6390bd451dad555545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81f33393cd2fe6390bd451dad555545">&#9670;&#160;</a></span>poolInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void poolInit </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint_fast32_t const&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint_fast16_t const&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSto</td><td>pointer to the storage for the event pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSize</td><td>size of the storage for the pool in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>You might initialize many event pools by making many consecutive calls to the <a class="el" href="namespace_q_p_1_1_q_f.html#ab81f33393cd2fe6390bd451dad555545" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a> function. However, for the simplicity of the internal implementation, you must initialize event pools in the ascending order of the event size.</dd>
<dd>
The actual number of events available in the pool might be actually less than (<code>poolSize / evtSize</code>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="namespace_q_p_1_1_q_f.html#a10a7c81ff3770d311e78876574dfd0f8" title="This function returns the minimum of free entries of the given event pool.">QF::getPoolMin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="namespace_q_p_1_1_q_f.html#ab81f33393cd2fe6390bd451dad555545" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> initialization example for <a class="el" href="namespace_q_p_1_1_q_f.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="QF initialization.">QF::init()</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>cannot exceed the number of available memory pools</dd>
<dd>
<a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> event pools must be initialized in ascending order of evtSize</dd>
<dd>
cannot exceed the number of available memory pools</dd>
<dd>
<a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> event pools must be initialized in ascending order of evtSize</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00097">97</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a96f78ae7178a02a2bb60889d413c6df4" name="a96f78ae7178a02a2bb60889d413c6df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f78ae7178a02a2bb60889d413c6df4">&#9670;&#160;</a></span>newX_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> * newX_ </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast16_t const&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint_fast16_t const&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8hpp.html#a17507c4fc030f571427f3a79e83d4277">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates an event dynamically from one of the <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> event pools.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the size (in bytes) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>the number of un-allocated events still available in a given event pool after the allocation completes. The special value <a class="el" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034" title="Special value of margin that causes asserting failure in case event allocation or event posting fails...">QF::NO_MARGIN</a> means that this function will assert if allocation fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>the signal to be assigned to the allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly allocated event. This pointer can be nullptr only if margin!=0 and the event cannot be allocated with the specified margin still available in the given pool.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> function <a class="el" href="namespace_q_p_1_1_q_f.html#a96f78ae7178a02a2bb60889d413c6df4" title="Internal QF implementation of creating new dynamic mutable event.">QF::newX_()</a> raises an assertion when the margin argument is <a class="el" href="namespace_q_p_1_1_q_f.html#a75157d4683e3ffe18bbd169033a7c034" title="Special value of margin that causes asserting failure in case event allocation or event posting fails...">QF::NO_MARGIN</a> and allocation of the event turns out to be impossible due to event pool depletion, or incorrect (too big) size of the requested event.</dd>
<dd>
The application code should not call this function directly. The only allowed use is thorough the macros <a class="el" href="qf_8hpp.html#a85513d80fc73d015efff2596428e4703" title="Allocate a dynamic event (case when QP::QEvt is not a POD)">Q_NEW()</a> or <a class="el" href="qf_8hpp.html#a190067e72a37774fa0ecfc84dba14615" title="Non-asserting allocate a dynamic event (case when QP::QEvt is not a POD)">Q_NEW_X()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00125">125</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a7d5f70fa40bdb5a9ed3524c5309be685" name="a7d5f70fa40bdb5a9ed3524c5309be685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5f70fa40bdb5a9ed3524c5309be685">&#9670;&#160;</a></span>gc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements a garbage collector for dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero <code>e-&gt;poolId_</code> attribute.) Next, the function decrements the reference counter of the event (<code>e-&gt;refCtr_</code>), and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to recycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have no need to call <a class="el" href="namespace_q_p_1_1_q_f.html#a7d5f70fa40bdb5a9ed3524c5309be685" title="Recycle a dynamic event.">QF::gc()</a> directly. The <a class="el" href="namespace_q_p_1_1_q_f.html#a7d5f70fa40bdb5a9ed3524c5309be685" title="Recycle a dynamic event.">QF::gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="class_q_p_1_1_q_e_queue.html" title="Native QF Event Queue class.">QP::QEQueue</a>). Such queues are processed outside of <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> and the automatic garbage collection is <b>NOT</b> performed for these events. In this case you need to call <a class="el" href="namespace_q_p_1_1_q_f.html#a7d5f70fa40bdb5a9ed3524c5309be685" title="Recycle a dynamic event.">QF::gc()</a> explicitly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00184">184</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a8b2404cde36d1b1209a1cf894fcdd79f" name="a8b2404cde36d1b1209a1cf894fcdd79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2404cde36d1b1209a1cf894fcdd79f">&#9670;&#160;</a></span>poolGetMaxBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast16_t poolGetMaxBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00243">243</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="acc01bf7f20f6517953de5ef28af442fb" name="acc01bf7f20f6517953de5ef28af442fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc01bf7f20f6517953de5ef28af442fb">&#9670;&#160;</a></span>newRef_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const  * newRef_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>evtRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and returns a new reference to the current event e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the current event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created reference to the event <code>e</code></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8hpp.html#a10162978b156ab5d2fd2e3a7aa744ac0" title="Create a new reference of the current event e">Q_NEW_REF()</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the event must be dynamic and the provided event reference must not be already in use</dd>
<dd>
the event must be dynamic and the provided event reference must not be already in use</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00248">248</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a89a52e38f626220d0568f56446bb09c7" name="a89a52e38f626220d0568f56446bb09c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a52e38f626220d0568f56446bb09c7">&#9670;&#160;</a></span>deleteRef_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteRef_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_p_1_1_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>evtRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes an existing reference to the event e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8hpp.html#aaed009a86c52cf2b8d811389fabb5f23" title="Delete the event reference.">Q_DELETE_REF()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00276">276</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a10a7c81ff3770d311e78876574dfd0f8" name="a10a7c81ff3770d311e78876574dfd0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a7c81ff3770d311e78876574dfd0f8">&#9670;&#160;</a></span>getPoolMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast16_t getPoolMin </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t const&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function obtains the minimum number of free blocks in the given event pool since this pool has been initialized by a call to <a class="el" href="namespace_q_p_1_1_q_f.html#ab81f33393cd2fe6390bd451dad555545" title="Event pool initialization for dynamic allocation of events.">QP::QF::poolInit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolId</td><td>event pool ID in the range 1..<a class="el" href="namespace_q_p_1_1_q_f.html#a21fe7d509e4fdffeb1bb258eb99202bd" title="number of initialized event pools">QF::maxPool_</a>, where <a class="el" href="namespace_q_p_1_1_q_f.html#a21fe7d509e4fdffeb1bb258eb99202bd" title="number of initialized event pools">QF::maxPool_</a> is the number of event pools initialized with the function <a class="el" href="namespace_q_p_1_1_q_f.html#ab81f33393cd2fe6390bd451dad555545" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of unused blocks in the given event pool. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>the poolId must be in range</dd>
<dd>
the poolId must be in range</dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00292">292</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a996109d745da0df30e1ac64d2975ee01" name="a996109d745da0df30e1ac64d2975ee01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996109d745da0df30e1ac64d2975ee01">&#9670;&#160;</a></span>bzero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bzero </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint_fast16_t const&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears a memory buffer by writing zeros byte-by-byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>pointer to the beginning of a memory buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the memory buffer to clear (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The main application of this function is clearing the internal <a class="el" href="namespace_q_p_1_1_q_f.html" title="hierarchical event processor and active object framework">QF</a> variables upon startup. This is done to avoid problems with non-standard startup code provided with some compilers and toolchains (e.g., TI DSPs or Microchip MPLAB), which does not zero the uninitialized variables, as required by the C++ standard. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__qact_8cpp_source.html#l00107">107</a> of file <a class="el" href="qf__qact_8cpp_source.html">qf_qact.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a411345fbc8d3502ee62bd80cc607376b" name="a411345fbc8d3502ee62bd80cc607376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411345fbc8d3502ee62bd80cc607376b">&#9670;&#160;</a></span>intLock_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast8_t volatile intLock_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf__qact_8cpp_source.html#l00077">77</a> of file <a class="el" href="qf__qact_8cpp_source.html">qf_qact.cpp</a>.</p>

</div>
</div>
<a id="ac03f48742df08a06b203ef53de9409da" name="ac03f48742df08a06b203ef53de9409da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03f48742df08a06b203ef53de9409da">&#9670;&#160;</a></span>intNest_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast8_t volatile intNest_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf__qact_8cpp_source.html#l00087">87</a> of file <a class="el" href="qf__qact_8cpp_source.html">qf_qact.cpp</a>.</p>

</div>
</div>
<a id="a75157d4683e3ffe18bbd169033a7c034" name="a75157d4683e3ffe18bbd169033a7c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75157d4683e3ffe18bbd169033a7c034">&#9670;&#160;</a></span>NO_MARGIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint_fast16_t NO_MARGIN {0xFFFFU}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8hpp_source.html#l01383">1383</a> of file <a class="el" href="qf_8hpp_source.html">qf.hpp</a>.</p>

</div>
</div>
<a id="a2fff89f1c6ead93de377d5d17ae675fc" name="a2fff89f1c6ead93de377d5d17ae675fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fff89f1c6ead93de377d5d17ae675fc">&#9670;&#160;</a></span>readySet_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_p_1_1_q_p_set.html">QPSet</a> readySet_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf__qact_8cpp_source.html#l00097">97</a> of file <a class="el" href="qf__qact_8cpp_source.html">qf_qact.cpp</a>.</p>

</div>
</div>
<a id="af8c858e1104e86dd9b4b2c0630f2bf4d" name="af8c858e1104e86dd9b4b2c0630f2bf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c858e1104e86dd9b4b2c0630f2bf4d">&#9670;&#160;</a></span>ePool_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qk_8hpp.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a> ePool_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00084">84</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
<a id="a21fe7d509e4fdffeb1bb258eb99202bd" name="a21fe7d509e4fdffeb1bb258eb99202bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fe7d509e4fdffeb1bb258eb99202bd">&#9670;&#160;</a></span>maxPool_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast8_t maxPool_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf__dyn_8cpp_source.html#l00073">73</a> of file <a class="el" href="qf__dyn_8cpp_source.html">qf_dyn.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_q_p.html">QP</a></li><li class="navelem"><a class="el" href="namespace_q_p_1_1_q_f.html">QF</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C++ 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
