<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: QF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">7.2.1</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_q_f.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="struct_q_f-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">QF Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> active object framework.
 <a href="struct_q_f.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qf_8h_source.html">qf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adac7eccb860d910c4e446d3143798bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#adac7eccb860d910c4e446d3143798bba">QF_init</a> (void)</td></tr>
<tr class="separator:adac7eccb860d910c4e446d3143798bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9cb86740bf55c5ad55c1d44fd35921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> (void)</td></tr>
<tr class="separator:adf9cb86740bf55c5ad55c1d44fd35921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779a1bc9482e2d489dc87751cd100fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run</a> (void)</td></tr>
<tr class="separator:a779a1bc9482e2d489dc87751cd100fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29692c0dcab731199b5beb5847484ab7"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a29692c0dcab731199b5beb5847484ab7">QF_getQueueMin</a> (uint_fast8_t const prio)</td></tr>
<tr class="separator:a29692c0dcab731199b5beb5847484ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189a6d2ece787717c81fbf51fd180732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup</a> (void)</td></tr>
<tr class="separator:a189a6d2ece787717c81fbf51fd180732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup</a> (void)</td></tr>
<tr class="separator:a5d7e181f2e679e1fa77c1e915fbee3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit</a> (void *const poolSto, uint_fast32_t const poolSize, uint_fast16_t const evtSize)</td></tr>
<tr class="separator:a1c4fc5636c2bc2e9d47e958aac05b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c89d3e5e55aeeec9175ec95635476ce"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a7c89d3e5e55aeeec9175ec95635476ce">QF_poolGetMaxBlockSize</a> (void)</td></tr>
<tr class="separator:a7c89d3e5e55aeeec9175ec95635476ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#ae52d81b1bd2cab6523fbe13cb5d79190">QF_getPoolMin</a> (uint_fast8_t const poolId)</td></tr>
<tr class="separator:ae52d81b1bd2cab6523fbe13cb5d79190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967a2e62ed579b0e9084e1f3b82665a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a967a2e62ed579b0e9084e1f3b82665a2">QF_onContextSw</a> (<a class="el" href="struct_q_active.html">QActive</a> *prev, <a class="el" href="struct_q_active.html">QActive</a> *next)</td></tr>
<tr class="separator:a967a2e62ed579b0e9084e1f3b82665a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44228cad4517189b1f57b97c27837628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a44228cad4517189b1f57b97c27837628">QF_bzero</a> (void *const start, uint_fast16_t const len)</td></tr>
<tr class="separator:a44228cad4517189b1f57b97c27837628"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aff7b59f569ec689a7580bd6911daafd5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#aff7b59f569ec689a7580bd6911daafd5">dummy</a></td></tr>
<tr class="separator:aff7b59f569ec689a7580bd6911daafd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad3bc25ebbfc2c2c433f8762a77136366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_evt.html">QEvt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#ad3bc25ebbfc2c2c433f8762a77136366">QF_newX_</a> (uint_fast16_t const evtSize, uint_fast16_t const margin, <a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const sig)</td></tr>
<tr class="separator:ad3bc25ebbfc2c2c433f8762a77136366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a7aa4e9d39b8af089405cb829e2cc5a24">QF_gc</a> (<a class="el" href="struct_q_evt.html">QEvt</a> const *const e)</td></tr>
<tr class="separator:a7aa4e9d39b8af089405cb829e2cc5a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4449d368362c7fc1d1ddc258027d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_evt.html">QEvt</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#aee4449d368362c7fc1d1ddc258027d53">QF_newRef_</a> (<a class="el" href="struct_q_evt.html">QEvt</a> const *const e, void const *const evtRef)</td></tr>
<tr class="separator:aee4449d368362c7fc1d1ddc258027d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb373ddc448c4198e4247b6c6ff3e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#aebb373ddc448c4198e4247b6c6ff3e69">QF_deleteRef_</a> (void const *const evtRef)</td></tr>
<tr class="separator:aebb373ddc448c4198e4247b6c6ff3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a15e3d933837d3df4558d4ce88e5ceab4"><td class="memItemLeft" align="right" valign="top">uint_fast8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#a15e3d933837d3df4558d4ce88e5ceab4">QF_intLock_</a></td></tr>
<tr class="separator:a15e3d933837d3df4558d4ce88e5ceab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb3060c94d42ed0893f0296509310ac"><td class="memItemLeft" align="right" valign="top">uint_fast8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#aadb3060c94d42ed0893f0296509310ac">QF_intNest_</a></td></tr>
<tr class="separator:aadb3060c94d42ed0893f0296509310ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9261926a1d9184651ce3704275c9b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qf_8h.html#struct_q_p_set">QPSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_f.html#aa9261926a1d9184651ce3704275c9b40">QF_readySet_</a></td></tr>
<tr class="separator:aa9261926a1d9184651ce3704275c9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l01332">1332</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adac7eccb860d910c4e446d3143798bba" name="adac7eccb860d910c4e446d3143798bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac7eccb860d910c4e446d3143798bba">&#9670;&#160;</a></span>QF_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> initialization</p>
<p>Initializes <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> and must be called exactly once before any other <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> function. Typcially, <a class="el" href="struct_q_f.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a> is called from main() even before initializing the Board Support Package (BSP).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_q_f.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a> clears the internal <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> variables, so that the framework can start correctly even if the startup code fails to clear the uninitialized data (as is required by the C Standard). </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8c_source.html#l00144">144</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a id="adf9cb86740bf55c5ad55c1d44fd35921" name="adf9cb86740bf55c5ad55c1d44fd35921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9cb86740bf55c5ad55c1d44fd35921">&#9670;&#160;</a></span>QF_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function invoked by the application layer to stop the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> application and return control to the OS/Kernel.</p>
<p>This function stops the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> application. After calling this function, <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this function is for terminating the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</p>
<dl class="section attention"><dt>Attention</dt><dd>After calling <a class="el" href="struct_q_f.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop()</a> the application must terminate and cannot continue. In particular, <a class="el" href="struct_q_f.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop()</a> is <b>not</b> intended to be followed by a call to <a class="el" href="struct_q_f.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a> to "resurrect" the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_q_f.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8c_source.html#l00169">169</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a id="a779a1bc9482e2d489dc87751cd100fdb" name="a779a1bc9482e2d489dc87751cd100fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779a1bc9482e2d489dc87751cd100fdb">&#9670;&#160;</a></span>QF_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qassert_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> QF_run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfers control to <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> to run the application.</p>
<p><a class="el" href="struct_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a> is typically called from your startup code after you initialize the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> and start at least one active object with <a class="el" href="qf_8h.html#a4cdbac20a04929fedd879615f0ddda00">QACTIVE_START()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>In <a class="el" href="struct_q_k.html" title="QK preemptive non-blocking kernel.">QK</a>, the <a class="el" href="struct_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a> does not return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qk_8c_source.html#l00175">175</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a id="a29692c0dcab731199b5beb5847484ab7" name="a29692c0dcab731199b5beb5847484ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29692c0dcab731199b5beb5847484ab7">&#9670;&#160;</a></span>QF_getQueueMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t QF_getQueueMin </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t const&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the minimum of free entries of the given event queue.</p>
<p>Queries the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only when the native <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> event queue implementation is used. Requesting the queue minimum of an unused priority level raises an assertion in the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a>. (A priority level becomes used in <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> after the call to the <a class="el" href="qf__qact_8c.html#abe6de335bea204db67cbd96fbb988f2b">QActive_register_()</a> function.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Priority of the active object, whose queue is queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum of free ever present in the given event queue of an active object with priority <code>prio</code>, since the active object was started. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__actq_8c_source.html#l00315">315</a> of file <a class="el" href="qf__actq_8c_source.html">qf_actq.c</a>.</p>

</div>
</div>
<a id="a189a6d2ece787717c81fbf51fd180732" name="a189a6d2ece787717c81fbf51fd180732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189a6d2ece787717c81fbf51fd180732">&#9670;&#160;</a></span>QF_onStartup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onStartup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Startup <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> callback.</p>
<p>The purpose of the <a class="el" href="struct_q_f.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup()</a> callback is to configure and enable hardware interrupts. The callback is invoked from <a class="el" href="struct_q_f.html#a779a1bc9482e2d489dc87751cd100fdb">QF_run()</a>, right before starting the underlying real-time kernel. By that time, the application is considered ready to receive and service interrupts.</p>
<p>This function is application-specific and is not implemented in <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a>, but rather in the Board Support Package (BSP) for the given application. </p>

</div>
</div>
<a id="a5d7e181f2e679e1fa77c1e915fbee3e0" name="a5d7e181f2e679e1fa77c1e915fbee3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7e181f2e679e1fa77c1e915fbee3e0">&#9670;&#160;</a></span>QF_onCleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onCleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleanup <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> callback.</p>
<p><a class="el" href="struct_q_f.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup()</a> is called in some <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> ports before <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> returns to the underlying real-time kernel or operating system.</p>
<p>This function is strongly platform-specific and is not implemented in the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a>, but either in the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> port or in the Board Support Package (BSP) for the given application. Some <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> ports might not require implementing <a class="el" href="struct_q_f.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_q_f.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop()</a> </dd></dl>

</div>
</div>
<a id="a1c4fc5636c2bc2e9d47e958aac05b8e1" name="a1c4fc5636c2bc2e9d47e958aac05b8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4fc5636c2bc2e9d47e958aac05b8e1">&#9670;&#160;</a></span>QF_poolInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_poolInit </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t const&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t const&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Event pool initialization for dynamic allocation of events.</p>
<p>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSto</td><td>pointer to the storage for the event pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poolSize</td><td>size of the storage for the pool in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>You might initialize many event pools by making many consecutive calls to the <a class="el" href="struct_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit()</a> function. However, for the simplicity of the internal implementation, you must initialize event pools in the <b>ascending order</b> of the event size.</dd></dl>
<p>Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can be adapted for <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> event pools. In case such support is missing, <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> provides a native <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> event pool implementation. The macro <a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a> determines the type of event pool used by a particular <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> port. See structure <a class="el" href="struct_q_m_pool.html" title="Native QF Memory Pool.">QMPool</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The actual number of events available in the pool might be actually less than (<code>poolSize</code> / <code>evtSize</code>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="struct_q_f.html#ae52d81b1bd2cab6523fbe13cb5d79190">QF_getPoolMin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="struct_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> initialization example for <a class="el" href="struct_q_f.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a> </dd></dl>

</div>
</div>
<a id="a7c89d3e5e55aeeec9175ec95635476ce" name="a7c89d3e5e55aeeec9175ec95635476ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c89d3e5e55aeeec9175ec95635476ce">&#9670;&#160;</a></span>QF_poolGetMaxBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t QF_poolGetMaxBlockSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain the block size of any registered event pools.</p>
<p>Obtain the block size of any registered event pools </p>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00114">114</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="ae52d81b1bd2cab6523fbe13cb5d79190" name="ae52d81b1bd2cab6523fbe13cb5d79190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52d81b1bd2cab6523fbe13cb5d79190">&#9670;&#160;</a></span>QF_getPoolMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t QF_getPoolMin </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t const&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain the minimum of free entries of the given event pool.</p>
<p>This function obtains the minimum number of free blocks in the given event pool since this pool has been initialized by a call to <a class="el" href="struct_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poolId</td><td>event pool ID in the range 1..QF_maxPool_, where QF_maxPool_ is the number of event pools initialized with the function <a class="el" href="struct_q_f.html#a1c4fc5636c2bc2e9d47e958aac05b8e1">QF_poolInit()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of unused blocks in the given event pool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00119">119</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="ad3bc25ebbfc2c2c433f8762a77136366" name="ad3bc25ebbfc2c2c433f8762a77136366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bc25ebbfc2c2c433f8762a77136366">&#9670;&#160;</a></span>QF_newX_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_evt.html">QEvt</a> * QF_newX_ </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t const&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t const&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep_8h.html#ad11e2d4dff3c15b0b5f9a13a47c7fb1a">enum_t</a> const&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> implementation of creating new dynamic event.</p>
<p>Allocates an event dynamically from one of the <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> event pools.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtSize</td><td>the size (in bytes) of the event to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">margin</td><td>the number of un-allocated events still available in a given event pool after the allocation completes. The special value <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a> means that this function will assert if allocation fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>the signal to be assigned to the allocated event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly allocated event. This pointer can be NULL only if margin != <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a> and the event cannot be allocated with the specified margin still available in the given pool.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The internal <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> function <a class="el" href="struct_q_f.html#ad3bc25ebbfc2c2c433f8762a77136366">QF_newX_()</a> raises an assertion when the <code>margin</code> parameter is <a class="el" href="qf_8h.html#a3c1957439cb1ecff92be7b7401bf3159">QF_NO_MARGIN</a> and allocation of the event turns out to be impossible due to event pool depletion, or incorrect (too big) size of the requested event.</dd>
<dd>
The application code should not call this function directly. The only allowed use is thorough the macros <a class="el" href="qf_8h.html#a85513d80fc73d015efff2596428e4703">Q_NEW()</a> or <a class="el" href="qf_8h.html#a190067e72a37774fa0ecfc84dba14615">Q_NEW_X()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00133">133</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a7aa4e9d39b8af089405cb829e2cc5a24" name="a7aa4e9d39b8af089405cb829e2cc5a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa4e9d39b8af089405cb829e2cc5a24">&#9670;&#160;</a></span>QF_gc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recycle a dynamic event</p>
<p>This function implements a simple garbage collector for the dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero e-&gt;poolId_ attribute.) Next, the function decrements the reference counter of the event (e-&gt;refCtr_), and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the event to recycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have no need to call <a class="el" href="struct_q_f.html#a7aa4e9d39b8af089405cb829e2cc5a24">QF_gc()</a> directly. The <a class="el" href="struct_q_f.html#a7aa4e9d39b8af089405cb829e2cc5a24">QF_gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="struct_q_e_queue.html" title="Native QF Event Queue.">QEQueue</a>). Such queues are processed outside of <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> and the automatic garbage collection is <b>NOT</b> performed for these events. In this case you need to call <a class="el" href="struct_q_f.html#a7aa4e9d39b8af089405cb829e2cc5a24">QF_gc()</a> explicitly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00192">192</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="aee4449d368362c7fc1d1ddc258027d53" name="aee4449d368362c7fc1d1ddc258027d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4449d368362c7fc1d1ddc258027d53">&#9670;&#160;</a></span>QF_newRef_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_evt.html">QEvt</a> const  * QF_newRef_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_evt.html">QEvt</a> const *const&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>evtRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> implementation of creating new event reference.</p>
<p>Creates and returns a new reference to the current event e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>pointer to the current event </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created reference to the event <code>e</code></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8h.html#a10162978b156ab5d2fd2e3a7aa744ac0">Q_NEW_REF()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00240">240</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="aebb373ddc448c4198e4247b6c6ff3e69" name="aebb373ddc448c4198e4247b6c6ff3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb373ddc448c4198e4247b6c6ff3e69">&#9670;&#160;</a></span>QF_deleteRef_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_deleteRef_ </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>evtRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> implementation of deleting event reference.</p>
<p>Deletes an existing reference to the event e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">evtRef</td><td>the event reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. The only allowed use is thorough the macro <a class="el" href="qf_8h.html#aaed009a86c52cf2b8d811389fabb5f23">Q_DELETE_REF()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="qf__dyn_8c_source.html#l00272">272</a> of file <a class="el" href="qf__dyn_8c_source.html">qf_dyn.c</a>.</p>

</div>
</div>
<a id="a967a2e62ed579b0e9084e1f3b82665a2" name="a967a2e62ed579b0e9084e1f3b82665a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967a2e62ed579b0e9084e1f3b82665a2">&#9670;&#160;</a></span>QF_onContextSw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_onContextSw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> context switch callback used in built-in kernels (<a class="el" href="struct_q_v.html" title="QV cooperative kernel.">QV</a>, <a class="el" href="struct_q_k.html" title="QK preemptive non-blocking kernel.">QK</a>, <a class="el" href="struct_q_x_k.html" title="The QXK kernel class.">QXK</a>)</p>
<p>This callback function provides a mechanism to perform additional custom operations when one of the built-in kernels switches context from one thread to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev</td><td>pointer to the previous thread (active object) (prev==0 means that <code>prev</code> was the idle loop) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">next</td><td>pointer to the next thread (active object) (next==0) means that <code>next</code> is the idle loop) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><a class="el" href="struct_q_f.html#a967a2e62ed579b0e9084e1f3b82665a2">QF_onContextSw()</a> is invoked with interrupts <b>disabled</b> and must also return with interrupts <b>disabled</b>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is enabled by defining the macro <a class="el" href="config_8h.html#a3e0c41a1acf5990304c36eecd99e930d">QF_ON_CONTEXT_SW</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef QF_ON_CONTEXT_SW</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* NOTE: the context-switch callback is called with interrupts DISABLED */</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="struct_q_f.html#a967a2e62ed579b0e9084e1f3b82665a2">QF_onContextSw</a>(<a class="code hl_class" href="struct_q_active.html">QActive</a> *prev, <a class="code hl_class" href="struct_q_active.html">QActive</a> *next) {</div>
<div class="line">    (void)prev;</div>
<div class="line">    <span class="keywordflow">if</span> (next != (<a class="code hl_class" href="struct_q_active.html">QActive</a> *)0) { <span class="comment">/* next is not the idle thread? */</span></div>
<div class="line">        _impure_ptr = next-&gt;<a class="code hl_variable" href="struct_q_active.html#a93793c0cf48b84dae3d823a7e2b0d5b5">thread</a>; <span class="comment">/* switch to next TLS */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* If you use QS software tracing, use the _NOCRIT() begin/end */</span></div>
<div class="line">    <a class="code hl_define" href="qs_8h.html#a98ae9bc427910662dc53ed1d15aaa044">QS_BEGIN_NOCRIT</a>(CONTEXT_SW, 0U)</div>
<div class="line">        QS_OBJ(prev);</div>
<div class="line">        QS_OBJ(next);</div>
<div class="line">    <a class="code hl_define" href="qs_8h.html#a2d38d50c6d69094bbe3bee00de5140d0">QS_END_NOCRIT</a>()</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* QF_ON_CONTEXT_SW */</span><span class="preprocessor"></span></div>
<div class="ttc" id="aqs_8h_html_a2d38d50c6d69094bbe3bee00de5140d0"><div class="ttname"><a href="qs_8h.html#a2d38d50c6d69094bbe3bee00de5140d0">QS_END_NOCRIT</a></div><div class="ttdeci">#define QS_END_NOCRIT()</div><div class="ttdef"><b>Definition:</b> <a href="qs_8h_source.html#l01107">qs.h:1107</a></div></div>
<div class="ttc" id="aqs_8h_html_a98ae9bc427910662dc53ed1d15aaa044"><div class="ttname"><a href="qs_8h.html#a98ae9bc427910662dc53ed1d15aaa044">QS_BEGIN_NOCRIT</a></div><div class="ttdeci">#define QS_BEGIN_NOCRIT(rec_, qs_id_)</div><div class="ttdef"><b>Definition:</b> <a href="qs_8h_source.html#l01100">qs.h:1100</a></div></div>
<div class="ttc" id="astruct_q_active_html"><div class="ttname"><a href="struct_q_active.html">QActive</a></div><div class="ttdoc">Active object class (based on the QHsm implementation strategy)</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00371">qf.h:371</a></div></div>
<div class="ttc" id="astruct_q_active_html_a93793c0cf48b84dae3d823a7e2b0d5b5"><div class="ttname"><a href="struct_q_active.html#a93793c0cf48b84dae3d823a7e2b0d5b5">QActive::thread</a></div><div class="ttdeci">QF_THREAD_TYPE thread</div><div class="ttdef"><b>Definition:</b> <a href="qf_8h_source.html#l00416">qf.h:416</a></div></div>
<div class="ttc" id="astruct_q_f_html_a967a2e62ed579b0e9084e1f3b82665a2"><div class="ttname"><a href="struct_q_f.html#a967a2e62ed579b0e9084e1f3b82665a2">QF::QF_onContextSw</a></div><div class="ttdeci">void QF_onContextSw(QActive *prev, QActive *next)</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a44228cad4517189b1f57b97c27837628" name="a44228cad4517189b1f57b97c27837628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44228cad4517189b1f57b97c27837628">&#9670;&#160;</a></span>QF_bzero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF_bzero </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t const&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear a specified region of memory to zero.</p>
<p>Clears a memory buffer by writing zeros byte-by-byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>pointer to the beginning of a memory buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the memory buffer to clear (in bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The main application of this function is clearing the internal <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> variables upon startup. This is done to avoid problems with non-standard startup code provided with some compilers and toolsets (e.g., TI DSPs or Microchip MPLAB), which does not zero the uninitialized variables, as required by the ANSI C standard. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aff7b59f569ec689a7580bd6911daafd5" name="aff7b59f569ec689a7580bd6911daafd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7b59f569ec689a7580bd6911daafd5">&#9670;&#160;</a></span>dummy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t dummy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l01333">1333</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="a15e3d933837d3df4558d4ce88e5ceab4" name="a15e3d933837d3df4558d4ce88e5ceab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e3d933837d3df4558d4ce88e5ceab4">&#9670;&#160;</a></span>QF_intLock_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast8_t volatile QF_intLock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interrupt lock up-down counter (used in some <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> ports ) </p>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l01340">1340</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="aadb3060c94d42ed0893f0296509310ac" name="aadb3060c94d42ed0893f0296509310ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb3060c94d42ed0893f0296509310ac">&#9670;&#160;</a></span>QF_intNest_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast8_t volatile QF_intNest_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interrupt nesting up-down counter (used in some <a class="el" href="struct_q_f.html" title="QF active object framework.">QF</a> ports ) </p>

<p class="definition">Definition at line <a class="el" href="qf_8h_source.html#l01346">1346</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a id="aa9261926a1d9184651ce3704275c9b40" name="aa9261926a1d9184651ce3704275c9b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9261926a1d9184651ce3704275c9b40">&#9670;&#160;</a></span>QF_readySet_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qf_8h.html#struct_q_p_set">QPSet</a> QF_readySet_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"Ready-set" of all threads used in the built-in kernels </p>

<p class="definition">Definition at line <a class="el" href="qf__pkg_8h_source.html#l00062">62</a> of file <a class="el" href="qf__pkg_8h_source.html">qf_pkg.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qf_8h_source.html">qf.h</a></li>
<li><a class="el" href="qf__pkg_8h_source.html">qf_pkg.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_q_f.html">QF</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.2.1</b> &nbsp;|&nbsp; Updated on Sun Jan 15 2023
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
