<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QTools: QUTest Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QTools
    &nbsp;<span id="projectnumber">7.2.1</span>
   </div>
   <div id="projectbrief">Collection of Host-Based Tools</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('qutest_conc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QUTest Concepts </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><span class="prev_button"><a class="el" href="qutest_use.html">Installation &amp; Use</a></span><span class="next_button"><a class="el" href="qutest_tut.html">QUTest&trade; Tutorial</a></span></p>
<h1><a class="anchor" id="qutest_rtc"></a>
Run-to-Completion Processing</h1>
<p>The central concept applied in QUTest is <b>Run-to-Completion (RTC)</b> processing, both in the <a class="el" href="qutest_fixture.html">test fixture</a> (Target) and in the <a class="el" href="qutest_script.html">test script</a> (Host). RTC processing means that the code progresses in discrete, uninterruptible steps and that new inputs (commands) are recognized only <em>after</em> the current RTC step completes.</p>
<dl class="section attention"><dt>Attention</dt><dd>RTC Processing is the key to understanding <b>how much output to expect from any given input</b> as well as <b>when a given input will be processed</b>.</dd></dl>
<p>Of course, it is not a coincidence that the RTC processing of QUTest exactly matches the RTC processing in event-driven systems of state machines. And the good news here is that for all interactions with state machines, the RTC output generated by a <a class="el" href="qutest_fixture.html">test fixture</a> will correspond exactly to the RTC step in the state machine.</p>
<p>However, a bit more tricky parts are the system reset, test initialization, and general processing of <a class="el" href="qutest_script.html#qutest_dsl-commands">commands</a> issued by <a class="el" href="qutest_script.html">test scripts</a>. The following sections explain these parts by means of annotated sequence diagrams.</p>
<dl class="section remark"><dt>Remarks</dt><dd>For simplicity, the sequence diagrams in this section omit the QSPY intermediary from the communication between a <a class="el" href="qutest_fixture.html">test fixture</a> (Target) and a <a class="el" href="qutest_script.html">test script</a>. It is understood that every command from the <a class="el" href="qutest_script.html">test script</a> goes to QSPY first and then is forwarded to the Target, and that every output from the Target goes through QSPY to reach the <a class="el" href="qutest_script.html">test script</a>.</dd></dl>
<h1><a class="anchor" id="qutest_reset"></a>
Target Reset</h1>
<p>Most individual tests in a <a class="el" href="qutest_script.html">test script</a> start with a clean <b>target reset</b>. The following sequence diagram shows the details of this process. The explanation section following the diagram clarifies the interesting points (labeled with <code>[xx]</code>). :</p>
<div class="image">
<img src="qutest_reset.gif" alt=""/>
<div class="caption">
Target reset</div></div>
    <p><code>[0]</code> A <a class="el" href="qutest_script.html">test script</a> executes the <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d">test()</a> command.</p>
<p><code>[1]</code> By default, each test starts with calling an internal function <code>reset()</code> to reset the Target. This <code>reset()</code> function sends the <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026a1a4d50e5e36c7b56b96f85df286c6c18">QS_RX_RESET</a> request to the <a class="el" href="qutest_fixture.html">test fixture</a>. After this, the <a class="el" href="qutest_script.html">test script</a> enters a wait state in which it waits for <a class="el" href="qpc__qs_8h.html#a6a73ed1da89600585ca91b5572941ea4">QS_TARGET_INFO</a> reply from the Target. <br  />
 The Target reset can be suppressed by the <code>NORESET</code> option given in the <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d">test()</a> command, which is illustrated in the <a class="el" href="qutest_conc.html#qutest_noreset">NORESET Tests</a> sequence diagram. Please note, however, that the first test in a <a class="el" href="qutest_script.html">test script</a> (test group) and any test immediately following an "assertion-test" <b>must</b> cleanly reset the Target (therefore it cannot use the <code>NORESET</code> option).</p>
<p><code>[2]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> processes the <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026a1a4d50e5e36c7b56b96f85df286c6c18">QS_RX_RESET</a> request immediately by calling the QS_onReset() callback inside the Target. <br  />
 Embedded Targets reboot automatically after resetting. In case of a <b>host executable</b>, however, QUTest&trade; (qutest.py) launches it again.<br  />
</p>
<p><code>[3]</code> The Target starts executing the <a class="el" href="qutest_fixture.html">test fixture</a> code from the beginning. After QS gets initialized (<a class="el" href="qpc__qs_8h.html#af22371611fe57862a37eb785debb7921">QS_INIT()</a>), the <a class="el" href="qutest_fixture.html">test fixture</a> sends the <a class="el" href="qpc__qs_8h.html#a6a73ed1da89600585ca91b5572941ea4">QS_TARGET_INFO</a> reply to the <a class="el" href="qutest_script.html">test script</a>.</p>
<p><code>[4]</code> Upon reception of the awaited <a class="el" href="qpc__qs_8h.html#a6a73ed1da89600585ca91b5572941ea4">QS_TARGET_INFO</a> reply, the <a class="el" href="qutest_script.html">test script</a> attempts to execute the <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> procedure. If <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> is defined in the script, it runs at this time. (This scenario assumes that <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> is defined and runs until step <code>[8]</code>).</p>
<p><code>[5]</code> A <a class="el" href="qutest_fixture.html">test fixture</a> continues the initialization RTC step and typically produces some <a class="el" href="qs.html#qs_dict">QS dictionaries</a>. <br  />
 The <a class="el" href="qs.html#qs_dict">QS dictionaries</a> are consumed by QSPY and are <b>not</b> forwarded to the <a class="el" href="qutest_script.html">test script</a>.</p>
<p><code>[6]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> might also produce some output that <b>is</b> forwarded to the <a class="el" href="qutest_script.html">test script</a>.</p>
<p><code>[7]</code> Any such output needs to be explicitly expected by the <a class="el" href="qutest_script.html">test script</a>. The <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> procedure is the ideal place to handle such output. <br  />
 The main purpose of the <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a>` procedure is to consume any output generated during the reset RTC step as well as to perform any setup that should follow the Target reset. In principle, instead of coding <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a>, you could place all this code directly at every test, but this would be repetitious. Defining <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> allows you to avoid such repetitions.</p>
<p><code>[8]</code> The <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> procedure ends and the <a class="el" href="qutest_script.html">test script</a> sends <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> to the Target.</p>
<p><code>[9]</code> <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> typically arrives while the <a class="el" href="qutest_fixture.html">test fixture</a> still runs the initialization RTC. Therefore, <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> is <b>not</b> processed immediately and its processing is delayed until the end of the current RTC step.</p>
<p><code>[10]</code> A <a class="el" href="qutest_fixture.html">test fixture</a> continues the initialization RTC step and might still produce some <a class="el" href="qs.html#qs_dict">QS dictionaries</a>.</p>
<p><code>[11]</code> Finally, the <a class="el" href="qutest_fixture.html">test fixture</a> completes the initialization RTC by calling <code>QF_run()</code>. <code>QF_run()</code> runs an event loop, in which it processes commands that have accumulated from the <a class="el" href="qutest_script.html">test script</a>.</p>
<p><code>[12]</code> The first such command is <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a>, which has been waiting in the input buffer.</p>
<p><code>[13]</code> The acknowledgment for the <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> is sent back to the <a class="el" href="qutest_script.html">test script</a>.</p>
<p><code>[14]</code> Upon reception of "Trg-Ack QS_RX_TEST_SETUP", the <a class="el" href="qutest_script.html">test script</a> attempts to execute the <a class="el" href="namespacequtest__dsl.html#ae6aaaf57101f6120f6c4e58ee92673f5">on_setup()</a> procedure. If <a class="el" href="namespacequtest__dsl.html#ae6aaaf57101f6120f6c4e58ee92673f5">on_setup()</a> is defined in the script, it runs at this time. <br  />
 The main purpose of the <a class="el" href="namespacequtest__dsl.html#ae6aaaf57101f6120f6c4e58ee92673f5">on_setup()</a> procedure is to consume any output generated from the <a class="el" href="qpc__qs_8h.html#a3d316077c13f8033c1a391590937e696">QS_onTestSetup()</a> callback in the <a class="el" href="qutest_fixture.html">test fixture</a> invoked in the next step [15]. Note also the <a class="el" href="qpc__qs_8h.html#a3d316077c13f8033c1a391590937e696">QS_onTestSetup()</a> runs in all tests, including <a class="el" href="qutest_conc.html#qutest_noreset">NORESET tests</a>.</p>
<p><code>[15]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> calls the <a class="el" href="qpc__qs_8h.html#a3d316077c13f8033c1a391590937e696">QS_onTestSetup()</a> callback function in the Target.</p>
<p><code>[16]</code> The <a class="el" href="qutest_script.html">test script</a> proceeds with commands defined after the <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d">test()</a> command. Processing of these commands is explained in sections <a class="el" href="qutest_conc.html#qutest_simple">Simple Commands</a> and <a class="el" href="qutest_conc.html#qutest_complex">Complex Commands</a>.</p>
<h1><a class="anchor" id="qutest_pause"></a>
Pausing the Reset</h1>
<p>As explained in the previous section, the initialization RTC step in the <a class="el" href="qutest_fixture.html">test fixture</a> extends throughout <code>main()</code>, from the beginning till the final call to <code>QF_run()</code>. The <a class="el" href="qutest_fixture.html">test fixture</a> is unable to process any commands from the <a class="el" href="qutest_script.html">test script</a> until the end of this long RTC step, which can limit the flexibility of the <a class="el" href="qutest_fixture.html">test fixture</a>.</p>
<p>For example, consider the <a class="el" href="qutest_fixture.html">test fixture</a> in the DPP example for QUTest (directory <span class="img folder"><code>qpc/examples/qutest/dpp/test</code></span>). This <a class="el" href="qutest_fixture.html">test fixture</a> reuses the <code>main()</code> function from the actual DPP application, which starts multiple active objects. To enable unit testing of a specific single active object, it would be very convenient if the <a class="el" href="qutest_script.html">test script</a> could set up the <a class="el" href="qs.html#qs_local">QS Local Filter</a> for the chosen active object component. Such a local filter would then select the output, such as initialization from a given AO. But the problem is that such a local filter requires the <a class="el" href="qs.html#qs_dict">QS object dictionary</a> to be already transmitted to QSPY. On the other hand, the local filter needs to take effect before the AOs are started. In other words, the initialization RTC step needs to be split into shorter pieces, right after sending the dictionaries, but before starting active objects.</p>
<p>For such situations, QUTest provides the <a class="el" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE()</a> macro, which pauses the execution of an RTC step and enters an event loop within the <a class="el" href="qutest_fixture.html">test fixture</a>. This, in turn, allows the <a class="el" href="qutest_fixture.html">test fixture</a> to process any commands from the <a class="el" href="qutest_script.html">test script</a>, before the RTC continues to completion (or to another <a class="el" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE()</a>, if needed).</p>
<p>The following <a class="el" href="qutest_fixture.html">test fixture</a> code illustrates the use of the <a class="el" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE()</a> macro:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">        <span class="keyword">static</span> QEvt <span class="keyword">const</span> *tableQueueSto[N_PHILO];</div>
<div class="line">        <span class="keyword">static</span> QEvt <span class="keyword">const</span> *philoQueueSto[N_PHILO][N_PHILO];</div>
<div class="line">        ~ ~ ~</div>
<div class="line"> </div>
<div class="line">        QF_init();    <span class="comment">/* initialize the framework and the underlying RT kernel */</span></div>
<div class="line">        BSP_init(argc, argv); <span class="comment">/* NOTE: calls QS_INIT() */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* object dictionaries... */</span></div>
<div class="line">        <a class="code hl_define" href="qpc__qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Table);</div>
<div class="line">        <a class="code hl_define" href="qpc__qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Philo[0]);</div>
<div class="line">        <a class="code hl_define" href="qpc__qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Philo[1]);</div>
<div class="line">        <a class="code hl_define" href="qpc__qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a>(AO_Philo[2]);</div>
<div class="line">        ~ ~ ~</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* pause execution of the test and wait for the test script to continue */</span></div>
<div class="line">[1]     <a class="code hl_define" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* initialize publish-subscribe... */</span></div>
<div class="line">        QF_psInit(subscrSto, Q_DIM(subscrSto));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* initialize event pools... */</span></div>
<div class="line">        QF_poolInit(smlPoolSto, <span class="keyword">sizeof</span>(smlPoolSto), <span class="keyword">sizeof</span>(smlPoolSto[0]));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* start the active objects... */</span></div>
<div class="line">        Philo_ctor(); <span class="comment">/* instantiate all Philosopher active objects */</span></div>
<div class="line">        <span class="keywordflow">for</span> (n = 0U; n &lt; N_PHILO; ++n) {</div>
<div class="line">            QACTIVE_START(AO_Philo[n],      <span class="comment">/* AO to start */</span></div>
<div class="line">                     (n + 1),               <span class="comment">/* QP priority of the AO */</span></div>
<div class="line">                     philoQueueSto[n],      <span class="comment">/* event queue storage */</span></div>
<div class="line">                     Q_DIM(philoQueueSto[n]), <span class="comment">/* queue length [events] */</span></div>
<div class="line">                     (<span class="keywordtype">void</span> *)0,             <span class="comment">/* stack storage (not used) */</span></div>
<div class="line">                     0U,                    <span class="comment">/* size of the stack [bytes] */</span></div>
<div class="line">                     (QEvt *)0);            <span class="comment">/* initialization event */</span></div>
<div class="line">        }</div>
<div class="line">        ~ ~ ~</div>
<div class="line"> </div>
<div class="line">[2]     <span class="keywordflow">return</span> QF_run(); <span class="comment">/* run the QF application */</span></div>
<div class="line">    }</div>
<div class="ttc" id="aqpc__qs_8h_html_a034206ff7f20a4e6426a5f554434643b"><div class="ttname"><a href="qpc__qs_8h.html#a034206ff7f20a4e6426a5f554434643b">QS_OBJ_DICTIONARY</a></div><div class="ttdeci">#define QS_OBJ_DICTIONARY(obj_)</div><div class="ttdef"><b>Definition:</b> <a href="qpc__qs_8h_source.html#l01331">qpc_qs.h:1331</a></div></div>
<div class="ttc" id="aqpc__qs_8h_html_ae5841714b4f420c33df0a5132cc3f2c7"><div class="ttname"><a href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE</a></div><div class="ttdeci">#define QS_TEST_PAUSE()</div><div class="ttdef"><b>Definition:</b> <a href="qpc__qs_8h_source.html#l01692">qpc_qs.h:1692</a></div></div>
</div><!-- fragment --><p><code>[1]</code> The <a class="el" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE()</a> macro pauses the initialization RTC after producing QS dictionaries, but before starting active objects.</p>
<p><code>[2]</code> The QF_run() function completes the initialization RTC.</p>
<p>The following sequence diagram shows the details of pausing a test. The explanation section following the diagram clarifies the interesting points (labeled with <code>[xx]</code>):</p>
<div class="image">
<img src="qutest_pause.gif" alt=""/>
<div class="caption">
Pausing a test</div></div>
    <p><code>[1]</code> The target reset proceeds as before and produces the <a class="el" href="qpc__qs_8h.html#a6a73ed1da89600585ca91b5572941ea4">QS_TARGET_INFO</a> trace record.</p>
<p><code>[2]</code> At some point, however, the <a class="el" href="qutest_fixture.html">test fixture</a> executes <b><a class="el" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE()</a></b>, which sends the <a class="el" href="qpc__qs_8h.html#ab2ccd183a19b0a8aa5b7b278df8240ac">QS_TEST_PAUSED</a> record to the <a class="el" href="qutest_script.html">test script</a>. At this point, the <a class="el" href="qutest_fixture.html">test fixture</a> enters the event loop, so the initialization RTC finishes and the <a class="el" href="qutest_fixture.html">test fixture</a> is now responsive to commands.</p>
<p><code>[3]</code> At this point, the <a class="el" href="qutest_script.html">test script</a> must be explicitily expecting QS_TEST_PAUSE by means of the <a class="el" href="namespacequtest__dsl.html#a3ebbc8b18a5ad6e03c186e6d14c6f439">expect_pause()</a> command. <br  />
 The best place to put <a class="el" href="namespacequtest__dsl.html#a3ebbc8b18a5ad6e03c186e6d14c6f439">expect_pause()</a> is the on_reset() callback function, which should be defined in <em>test scripts</em> corresponding to <em>test fixtures</em> that call <a class="el" href="qpc__qs_8h.html#ae5841714b4f420c33df0a5132cc3f2c7">QS_TEST_PAUSE()</a>.</p>
<p><code>[4]</code> The <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> callback can now execute commands that are processed <b>immediately</b> in the <a class="el" href="qutest_fixture.html">test fixture</a>.</p>
<p><code>[5]</code> Eventually thequtest_dsl:on_reset() "on_reset()" callback releases the <a class="el" href="qutest_fixture.html">test fixture</a> from the pause by executing the <a class="el" href="namespacequtest__dsl.html#acece2da8278f7d8b2bbd769258f949d6">continue_test()</a> command. This command sends <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026af3c0bff5d70c643897c9e88e65a3446b">QS_RX_TEST_CONTINUE</a> to the <a class="el" href="qutest_fixture.html">test fixture</a>.</p>
<p><code>[6]</code> Upon reception of <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026af3c0bff5d70c643897c9e88e65a3446b">QS_RX_TEST_CONTINUE</a>, the <a class="el" href="qutest_fixture.html">test fixture</a> continues the initialization in another RTC step.</p>
<p><code>[7]</code> The <a class="el" href="namespacequtest__dsl.html#afc75df84cbc29b702f684a19fefa4bbb">on_reset()</a> callback ends and the test script sends <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> to the Target.</p>
<p><code>[8]</code> The test proceeds as before.</p>
<p>The following <a class="el" href="qutest_script.html">test script</a> code illustrates the use of the <a class="el" href="namespacequtest__dsl.html#a3ebbc8b18a5ad6e03c186e6d14c6f439">expect_pause()</a> and <a class="el" href="namespacequtest__dsl.html#acece2da8278f7d8b2bbd769258f949d6">continue_test()</a> commands:</p>
<div class="fragment"><div class="line">    def on_reset():</div>
<div class="line">[1]     expect_pause()</div>
<div class="line">[2]     glb_filter(<a class="code hl_enumvalue" href="qspy_8h.html#a8dcf945571b727be2ac784fb2556bcdaadf5e1bb46a0abe33702c0ec950407159">GRP_SM</a>)</div>
<div class="line">        loc_filter(OBJ_SM_AO, <span class="stringliteral">&quot;AO_Philo&lt;2&gt;&quot;</span>)</div>
<div class="line">[3]     continue_test()</div>
<div class="line">[4]     expect(<span class="stringliteral">&quot;===RTC===&gt; St-Init  Obj=AO_Philo&lt;2&gt;,State=QHsm_top-&gt;Philo_thinking&quot;</span>)</div>
<div class="line">        expect(<span class="stringliteral">&quot;===RTC===&gt; St-Entry Obj=AO_Philo&lt;2&gt;,State=Philo_thinking&quot;</span>)</div>
<div class="line">        expect(<span class="stringliteral">&quot;@timestamp Init===&gt; Obj=AO_Philo&lt;2&gt;,State=Philo_thinking&quot;</span>)</div>
<div class="line">        glb_filter(GRP_SM_AO, GRP_UA)</div>
<div class="line">        current_obj(OBJ_SM_AO, <span class="stringliteral">&quot;AO_Philo&lt;2&gt;&quot;</span>)</div>
<div class="line">    }</div>
<div class="ttc" id="aqspy_8h_html_a8dcf945571b727be2ac784fb2556bcdaadf5e1bb46a0abe33702c0ec950407159"><div class="ttname"><a href="qspy_8h.html#a8dcf945571b727be2ac784fb2556bcdaadf5e1bb46a0abe33702c0ec950407159">GRP_SM</a></div><div class="ttdeci">@ GRP_SM</div><div class="ttdef"><b>Definition:</b> <a href="qspy_8h_source.html#l00179">qspy.h:179</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="qutest_noreset"></a>
NORESET Tests</h1>
<p>In some tests, you specifically don't want to reset the Target, but rather you want to pick up exactly where the previous test left off. For example, you wish to test a specific state of your state machine, which you reached by dispatching or posting a specific sequence of events to it in the previous tests.</p>
<p>For such tests, you can suppress the target reset by following the <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d">test()</a> command with the ::NORESET option. Such tests are called <a class="el" href="qutest_conc.html#qutest_noreset">NORESET Tests</a>.</p>
<dl class="section note"><dt>Note</dt><dd>A ::NORESET test is not allowed as the first test of a <em>test group</em> and also not after an <a class="el" href="qutest_conc.html#qutest_assert">Assertion Tests</a>.</dd></dl>
<p>The following sequence diagram shows the details of this process. The explanation section following the diagram clarifies the interesting points (labeled with <code>[xx]</code>):</p>
<div class="image">
<img src="qutest_noreset.gif" alt=""/>
<div class="caption">
NORESET Test</div></div>
    <p><code>[0]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> is done processing commands from any previous test(s) and is running an event loop.</p>
<p><code>[1]</code> The <a class="el" href="qutest_script.html">test script</a> executes the <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d">test(..., NORESET)</a> command.</p>
<p><code>[2]</code> The <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d">test(..., NORESET)</a> command sends the <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> command to the <a class="el" href="qutest_fixture.html">test fixture</a>.</p>
<p><code>[3]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> processes <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a> immediately, because it is running the event loop.</p>
<p><code>[4]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> responds with Trg-Ack <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a>.</p>
<p><code>[5]</code> Upon reception of Trg-Ack <a class="el" href="qpc__qs__pkg_8h.html#abf73d66c1a2a355d50741e010f11b026ac50689eb8f70b05ea6599383b64def50">QS_RX_TEST_SETUP</a>, the <a class="el" href="qutest_script.html">test script</a> attempts to execute the <a class="el" href="namespacequtest__dsl.html#ae6aaaf57101f6120f6c4e58ee92673f5">on_setup()</a> callback. If <a class="el" href="namespacequtest__dsl.html#ae6aaaf57101f6120f6c4e58ee92673f5">on_setup()</a> is defined in the script, it runs at this time. <br  />
 The main purpose of the <a class="el" href="namespacequtest__dsl.html#ae6aaaf57101f6120f6c4e58ee92673f5">on_setup()</a> callback is to consume any output generated from the <a class="el" href="qpc__qs_8h.html#a3d316077c13f8033c1a391590937e696">QS_onTestSetup()</a> callback in the test fixture invoked in the next step [6].</p>
<p><code>[6]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> calls the <a class="el" href="qpc__qs_8h.html#a3d316077c13f8033c1a391590937e696">QS_onTestSetup()</a> callback function in the Target.</p>
<p><code>[7]</code> The <a class="el" href="qutest_script.html">test script</a> proceeds with commands defined after the <a class="el" href="namespacequtest__dsl.html#ac0d4e644cd63337f7214b45a483e9c3d" title="start a new test">qutest_dsl::test()</a> "test()" command. Processing of these commands is explained in sections <a class="el" href="qutest_conc.html#qutest_simple">Simple Commands</a> and <a class="el" href="qutest_conc.html#qutest_complex">Complex Commands</a>.</p>
<h1><a class="anchor" id="qutest_assert"></a>
Assertion Tests</h1>
<p>The use of assertions in embedded code (and especially in safety-critical code) is considered one of the <b>best practices</b> and the QP frameworks provide assertion facilities specifically designed for deeply embedded systems.</p>
<p>Assuming that you are using QP assertions in your code, an assertion failure can happen during a unit test. When it happens, the <a class="el" href="qutest_fixture.html">test fixture</a> will produce the non-maskable <a class="el" href="qpc__qs_8h.html#a024157f7a402e0c0026e1c4dba1c7ce7">QS_ASSERT_FAIL</a> trace record. When this record arrives during a regular test, it will not be expected, so the test will fail. This is exactly what you want, because a failing assertion represents an error which needs to be fixed.</p>
<dl class="section note"><dt>Note</dt><dd>The QP assertion handler Q_onAssert() is defined in the <a class="el" href="qutest_fixture.html#qutest_stub">QUTest Stub</a>. This assertion handler is instrumented to produce the <a class="el" href="qpc__qs_8h.html#a024157f7a402e0c0026e1c4dba1c7ce7">QS_ASSERT_FAIL</a> trace record.</dd></dl>
<p>However, sometimes you specifically want to test the assertion code itself, so you intentionally force an assertion in your test. In that case an assertion failure is expected and the test passes when the assertion fails. Such tests are called "Assertion Tests" and QUTest&trade; has been specifically designed to support such tests.</p>
<p>Here is an example of an "Assertion Test":</p>
<div class="fragment"><div class="line">test(<span class="stringliteral">&quot;TIMEOUT-&gt;Philo_thinking (ASSERT)&quot;</span>)</div>
<div class="line">probe(<span class="stringliteral">&quot;QActive_post_&quot;</span>, 1)</div>
<div class="line">dispatch(<span class="stringliteral">&quot;TIMEOUT_SIG&quot;</span>)</div>
<div class="line">expect(<span class="stringliteral">&quot;@timestamp Disp===&gt; Obj=AO_Philo&lt;2&gt;,Sig=TIMEOUT_SIG,State=Philo_thinking&quot;</span>)</div>
<div class="line">expect(<span class="stringliteral">&quot;===RTC===&gt; St-Exit  Obj=AO_Philo&lt;2&gt;,State=Philo_thinking&quot;</span>)</div>
<div class="line">expect(<span class="stringliteral">&quot;@timestamp TstProbe Fun=QActive_post_,Data=1&quot;</span>)</div>
<div class="line">expect(<span class="stringliteral">&quot;@timestamp =ASSERT= Mod=qf_actq,Loc=110&quot;</span>)</div>
</div><!-- fragment --><p>As you can see, the test ends with an explicit expectation of an assertion failure: <a class="el" href="namespacequtest__dsl.html#ac04e5d768c1af3bbae0b177d0beb4d95">expect('@timestamp =ASSERT= Mod=qf_actq,Loc=...')</a>. This is very easy and natural in QUTest.</p>
<dl class="section note"><dt>Note</dt><dd>The only special treatment required here is that a test immediately following such an "Assertion Test" must necessarily reset the Target (it cannot be a <a class="el" href="qutest_conc.html#qutest_noreset">NORESET-Test</a>).</dd></dl>
<h1><a class="anchor" id="qutest_qspy"></a>
Categories of QSPY Output</h1>
<p>To write effective <em>test scripts</em> you need to understand the main categories of QSPY output, which are illustrated in the picture below:</p>
<div class="image">
<img src="qspy_cat.png" alt=""/>
</div>
  <div class="caption"><center><b>Categories of QSPY output</b></center></div><p><code>[0]</code> Information output generated internally by QSPY. This output is <em>not</em> sent to <em>test scripts</em>.</p>
<p><code>[1]</code> <a class="el" href="qspy_8h.html#struct_dictionary">Dictionary</a> trace records generated by the Target. This output is <em>not</em> forwarded to <em>test scripts</em>.</p>
<p><code>[2]</code> Acknowledgement trace records generated by the Target. This output <em>is</em> forwarded to <em>test scripts</em>, but is checked automatically and implicitly by the <em>test commands</em>.</p>
<p><code>[3]</code> Trace records generated by the Target. This output <em>is</em> forwarded to <em>test scripts</em> and must be checked <b>explicitly</b> by test expectations.</p>
<h1><a class="anchor" id="qutest_simple"></a>
Simple Commands</h1>
<p>Simple <a class="el" href="qutest_script.html">test script</a> commands do not produce any output from the Target, except for the "Trg-Ack" (acknowledgement). Examples of <code>&lt;SIMPLE-COMMAND&gt;</code> include <a class="el" href="namespacequtest__dsl.html#acf702f903742c2f42d257d97c1f343f2">glb_filter()</a>, <a class="el" href="namespacequtest__dsl.html#a3f26d7a020469125630042fa9e60186f">loc_filter()</a> and <a class="el" href="namespacequtest__dsl.html#af75ca468f88c149f84acd336a9dcd95b">current_obj()</a>.</p>
<div class="image">
<img src="qutest_simple.gif" alt=""/>
<div class="caption">
Simple command processing</div></div>
    <p><code>[1]</code> A <a class="el" href="qutest_script.html">test script</a> sends a <code>&lt;SIMPLE-COMMAND&gt;</code> to the <a class="el" href="qutest_fixture.html">test fixture</a>.</p>
<p><code>[2]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> receives the command and immediately starts processing it. </p>
<p><code>[3]</code> Processing of a command triggers an RTC step and produces only the "Trg-Ack  &lt;SIMPLE-COMMAND&gt;" (acknowledgement of the specific <code>&lt;SIMPLE-COMMAND&gt;</code>).</p>
<p><code>[4]</code> Immediately after sending the <code>&lt;SIMPLE-COMMAND&gt;</code>, the <a class="el" href="qutest_script.html">test script</a> enters an implicit expect state, in which it waits for the "Trg-Ack &lt;SIMPLE-COMMAND&gt;" output from the Target. The processing of the <code>&lt;SIMPLE-COMMAND&gt;</code> ends when the next output received from the Target exactly matches the expected output.</p>
<h1><a class="anchor" id="qutest_complex"></a>
Complex Commands</h1>
<p>Complex <a class="el" href="qutest_script.html">test script</a> commands might produce some output from the Target, not just the "Trg-Ack" (acknowledgement). Examples of <code>&lt;COMPLEX-COMMAND&gt;</code> include <a class="el" href="namespacequtest__dsl.html#a3464c8f9e716e6f77ff035152e22b0d2">command()</a>, <a class="el" href="namespacequtest__dsl.html#add569a1282fb45d0b4d51393f79d626c">dispatch()</a>, <a class="el" href="namespacequtest__dsl.html#ae352def70558b00abe928a52b0d905ec">post()</a> and <a class="el" href="namespacequtest__dsl.html#a096e09ec9d7444defc2d38a4cad0031b">tick()</a>.</p>
<div class="image">
<img src="qutest_complex.gif" alt=""/>
<div class="caption">
Complex command processing</div></div>
    <p><code>[1]</code> A <a class="el" href="qutest_script.html">test script</a> sends a <code>&lt;COMPLEX-COMMAND&gt;</code> to the <a class="el" href="qutest_fixture.html">test fixture</a>.</p>
<p><code>[2]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> receives the command and immediately starts processing it.</p>
<p><code>[3]</code> Processing of a command triggers an RTC step and produces only the "Trg-Ack  &lt;COMPLEX-COMMAND&gt;" (acknowledgement of the specific <code>&lt;COMPLEX-COMMAND&gt;</code>).</p>
<p><code>[4]</code> The <code>&lt;COMPLEX-COMMAND&gt;</code> must be followed in the <a class="el" href="qutest_script.html">test script</a> by the explicit expect() commands that consume any output produced by the command.</p>
<p><code>[5-6]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> produces some output.</p>
<p><code>[7]</code> Each such ouput is consumed by the matching expect() command.</p>
<p><code>[8]</code> The <a class="el" href="qutest_fixture.html">test fixture</a> sends the additional QS record "Trg-Done &lt;COMPLEX-COMMAND&gt;", which explicitly delimits the output from this particular command.</p>
<p><code>[9]</code> The <a class="el" href="qutest_script.html">test script</a> must consume the "Trg-Done &lt;COMPLEX-COMMAND&gt;" record by an explicit expect() command. </p>
<p><span class="prev_button"><a class="el" href="qutest_use.html">Installation &amp; Use</a></span><span class="next_button"><a class="el" href="qutest_tut.html">QUTest&trade; Tutorial</a></span> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="qutest.html">QUTest&trade; Unit Testing Harness</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QTools 7.2.1</b> &nbsp;|&nbsp; Updated on Thu Jan 26 2023
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2023 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QTools 7.2.1</b> &nbsp;|&nbsp; Updated on Thu Jan 26 2023
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
